<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL | Aismy&#39;Docs</title>
    <meta name="generator" content="VuePress 1.9.2">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="Aismy&#39;Docs">
    <meta name="keywords" content="vuepress,theme,blog,vdoing">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.906cd319.css" as="style"><link rel="preload" href="/assets/js/app.b738e2cf.js" as="script"><link rel="preload" href="/assets/js/2.ffb45a81.js" as="script"><link rel="preload" href="/assets/js/23.6a79feac.js" as="script"><link rel="prefetch" href="/assets/js/10.c2e0087a.js"><link rel="prefetch" href="/assets/js/11.515afe89.js"><link rel="prefetch" href="/assets/js/12.fab2a176.js"><link rel="prefetch" href="/assets/js/13.001935e7.js"><link rel="prefetch" href="/assets/js/14.b80dbf2e.js"><link rel="prefetch" href="/assets/js/15.1b1059f6.js"><link rel="prefetch" href="/assets/js/16.fcd1537c.js"><link rel="prefetch" href="/assets/js/17.9df6cc33.js"><link rel="prefetch" href="/assets/js/18.bd3b4e60.js"><link rel="prefetch" href="/assets/js/19.c0b3ce9a.js"><link rel="prefetch" href="/assets/js/20.546547fb.js"><link rel="prefetch" href="/assets/js/21.0692e109.js"><link rel="prefetch" href="/assets/js/22.941054f1.js"><link rel="prefetch" href="/assets/js/24.d7b40265.js"><link rel="prefetch" href="/assets/js/25.2f068444.js"><link rel="prefetch" href="/assets/js/26.39e773a6.js"><link rel="prefetch" href="/assets/js/27.0cc11d71.js"><link rel="prefetch" href="/assets/js/28.6e0bab80.js"><link rel="prefetch" href="/assets/js/29.aa305b1a.js"><link rel="prefetch" href="/assets/js/3.166f9e48.js"><link rel="prefetch" href="/assets/js/30.a9437cbd.js"><link rel="prefetch" href="/assets/js/31.d2300f1b.js"><link rel="prefetch" href="/assets/js/32.30060633.js"><link rel="prefetch" href="/assets/js/33.ddd9f9e8.js"><link rel="prefetch" href="/assets/js/34.102c62c1.js"><link rel="prefetch" href="/assets/js/35.da833d69.js"><link rel="prefetch" href="/assets/js/36.b4b83ef9.js"><link rel="prefetch" href="/assets/js/37.a549e9e3.js"><link rel="prefetch" href="/assets/js/38.e84bf93e.js"><link rel="prefetch" href="/assets/js/39.145b375f.js"><link rel="prefetch" href="/assets/js/4.2988106a.js"><link rel="prefetch" href="/assets/js/40.246cd152.js"><link rel="prefetch" href="/assets/js/41.530026b3.js"><link rel="prefetch" href="/assets/js/42.24a60b39.js"><link rel="prefetch" href="/assets/js/43.902a7b0b.js"><link rel="prefetch" href="/assets/js/44.4f8c78f2.js"><link rel="prefetch" href="/assets/js/5.58eac4fd.js"><link rel="prefetch" href="/assets/js/6.d50e78bb.js"><link rel="prefetch" href="/assets/js/7.977fe42a.js"><link rel="prefetch" href="/assets/js/8.289b9caf.js"><link rel="prefetch" href="/assets/js/9.6a3fba9d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.906cd319.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Aismy'Docs" class="logo"> <span class="site-name can-hide">Aismy'Docs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="https://www.aismy.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  📕博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🍵Java SE" class="dropdown-title"><a href="/pages/389d93/" class="link-title">🍵Java SE</a> <span class="title" style="display:none;">🍵Java SE</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/389d93/" class="nav-link">Java基础</a></li><li class="dropdown-item"><!----> <a href="/pages/aab896/" class="nav-link">集合</a></li><li class="dropdown-item"><!----> <a href="/pages/d2a30d/" class="nav-link">IO流</a></li><li class="dropdown-item"><!----> <a href="/pages/780f7d/" class="nav-link">注解和反射</a></li><li class="dropdown-item"><!----> <a href="/pages/8d2bfc/" class="nav-link">并发编程</a></li><li class="dropdown-item"><!----> <a href="/pages/e9d599/" class="nav-link">JVM</a></li><li class="dropdown-item"><!----> <a href="/pages/467393/" class="nav-link">新特性</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🌴数据库" class="dropdown-title"><a href="/pages/142be7/" aria-current="page" class="link-title router-link-exact-active router-link-active">🌴数据库</a> <span class="title" style="display:none;">🌴数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/142be7/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Mysql</a></li><li class="dropdown-item"><!----> <a href="/pages/1ce2e2/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/pages/62a615/" class="nav-link">ElasticSearch</a></li></ul></div></div><div class="nav-item"><a href="/pages/1b02d4/" class="nav-link">🚀后端框架</a></div><div class="nav-item"><a href="/pages/1fe252/" class="nav-link">🚀前端技术</a></div><div class="nav-item"><a href="/pages/83c955/" class="nav-link">🛠️开发工具</a></div> <a href="https://github.com/Aismy/aismy.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="https://www.aismy.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  📕博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🍵Java SE" class="dropdown-title"><a href="/pages/389d93/" class="link-title">🍵Java SE</a> <span class="title" style="display:none;">🍵Java SE</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/389d93/" class="nav-link">Java基础</a></li><li class="dropdown-item"><!----> <a href="/pages/aab896/" class="nav-link">集合</a></li><li class="dropdown-item"><!----> <a href="/pages/d2a30d/" class="nav-link">IO流</a></li><li class="dropdown-item"><!----> <a href="/pages/780f7d/" class="nav-link">注解和反射</a></li><li class="dropdown-item"><!----> <a href="/pages/8d2bfc/" class="nav-link">并发编程</a></li><li class="dropdown-item"><!----> <a href="/pages/e9d599/" class="nav-link">JVM</a></li><li class="dropdown-item"><!----> <a href="/pages/467393/" class="nav-link">新特性</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🌴数据库" class="dropdown-title"><a href="/pages/142be7/" aria-current="page" class="link-title router-link-exact-active router-link-active">🌴数据库</a> <span class="title" style="display:none;">🌴数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/142be7/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Mysql</a></li><li class="dropdown-item"><!----> <a href="/pages/1ce2e2/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/pages/62a615/" class="nav-link">ElasticSearch</a></li></ul></div></div><div class="nav-item"><a href="/pages/1b02d4/" class="nav-link">🚀后端框架</a></div><div class="nav-item"><a href="/pages/1fe252/" class="nav-link">🚀前端技术</a></div><div class="nav-item"><a href="/pages/83c955/" class="nav-link">🛠️开发工具</a></div> <a href="https://github.com/Aismy/aismy.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>数据库</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/142be7/" aria-current="page" class="active sidebar-link">MySQL</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_1-1-sql分类" class="sidebar-link">1.1 SQL分类</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_1-2-ddl-数据定义语言" class="sidebar-link">1. 2 DDL（数据定义语言）</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_1-3-dml-数据操作语言" class="sidebar-link">1.3 DML（数据操作语言）</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_1-4-dql-数据查询语言" class="sidebar-link">1.4 DQL（数据查询语言）</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_1-5-dcl" class="sidebar-link">1.5 DCL</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_2-1-字符串函数" class="sidebar-link">2.1 字符串函数</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_2-2-数值函数" class="sidebar-link">2.2 数值函数</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_2-3-日期函数" class="sidebar-link">2.3 日期函数</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_2-4-流程函数" class="sidebar-link">2.4 流程函数</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_3-1-常用约束" class="sidebar-link">3.1 常用约束</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_3-2-外键约束" class="sidebar-link">3.2 外键约束</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_4-1-概述" class="sidebar-link">4.1 概述</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_4-2-连接查询" class="sidebar-link">4.2 连接查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_4-3子查询" class="sidebar-link">4.3子查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_5-1-相关操作" class="sidebar-link">5.1 相关操作</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_5-2-四大特性acid" class="sidebar-link">5.2 四大特性ACID</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_5-2-并发事务可能引发的问题" class="sidebar-link">5.2 并发事务可能引发的问题</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_5-3事务的隔离级别" class="sidebar-link">5.3事务的隔离级别</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_6-1-mysql体系结构" class="sidebar-link">6.1 MySQL体系结构</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_6-2-存储引擎" class="sidebar-link">6.2 存储引擎</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_6-3-存储引擎特点" class="sidebar-link">6.3 存储引擎特点</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_6-4-存储引擎的选择" class="sidebar-link">6.4 存储引擎的选择</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_7-1索引结构" class="sidebar-link">7.1索引结构</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_7-2-索引分类" class="sidebar-link">7.2 索引分类</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_7-3-索引语法" class="sidebar-link">7.3 索引语法</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_7-4-sql性能分析" class="sidebar-link">7.4 SQL性能分析</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_7-5-索引使用规则" class="sidebar-link">7.5 索引使用规则</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_7-6-索引失效情况" class="sidebar-link">7.6 索引失效情况</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_7-7-sql-提示-指定要使用的索引" class="sidebar-link">7.7 SQL 提示(指定要使用的索引)</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_7-8-覆盖索引-回表查询" class="sidebar-link">7.8 覆盖索引&amp;回表查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_7-9-前缀索引" class="sidebar-link">7.9 前缀索引</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_7-10-单列索引-联合索引" class="sidebar-link">7.10 单列索引&amp;联合索引</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_7-11-设计原则" class="sidebar-link">7.11 设计原则</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_8-1-插入数据" class="sidebar-link">8.1 插入数据</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_8-2-主键优化" class="sidebar-link">8.2 主键优化</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_8-3-order-by优化" class="sidebar-link">8.3 order by优化</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_8-4-group-by优化" class="sidebar-link">8.4 group by优化</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_8-5-limit优化" class="sidebar-link">8. 5 limit优化</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_8-6-count优化" class="sidebar-link">8.6 count优化</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_8-7-update优化-避免行锁升级为表锁" class="sidebar-link">8.7 update优化（避免行锁升级为表锁）</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_9-1-、概述" class="sidebar-link">9.1 、概述</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_9-2-全局锁" class="sidebar-link">9.2 全局锁</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_9-3表级锁" class="sidebar-link">9.3表级锁</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_9-4-行级锁" class="sidebar-link">9.4 行级锁</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_10-1-逻辑存储结构" class="sidebar-link">10.1 逻辑存储结构</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_10-2-innodb-是如何存储数据的" class="sidebar-link">10.2 InnoDB 是如何存储数据的？</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_10-3-架构" class="sidebar-link">10.3 架构</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_10-4-事务原理" class="sidebar-link">10.4 事务原理</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#_10-5-mvcc" class="sidebar-link">10.5 MVCC</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#小结-2" class="sidebar-link">小结</a></li><li class="sidebar-sub-header level2"><a href="/pages/142be7/#详解buffer-pool" class="sidebar-link">详解Buffer Pool</a></li></ul></li><li><a href="/pages/1ce2e2/" class="sidebar-link">Redis</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_1-初识redis" class="sidebar-link">1.初识Redis</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_2-redis常见命令" class="sidebar-link">2.Redis常见命令</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_3-redis的java客户端" class="sidebar-link">3.Redis的Java客户端</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#开篇导读" class="sidebar-link">开篇导读</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_1、短信登录" class="sidebar-link">1、短信登录</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_2、商户查询缓存" class="sidebar-link">2、商户查询缓存</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_3、优惠卷秒杀" class="sidebar-link">3、优惠卷秒杀</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_4、分布式锁" class="sidebar-link">4、分布式锁</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_5、分布式锁-redission" class="sidebar-link">5、分布式锁-redission</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_6、秒杀优化" class="sidebar-link">6、秒杀优化</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_7、redis消息队列" class="sidebar-link">7、Redis消息队列</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_8、达人探店" class="sidebar-link">8、达人探店</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_9、好友关注" class="sidebar-link">9、好友关注</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_10、附近商户" class="sidebar-link">10、附近商户</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_11、用户签到" class="sidebar-link">11、用户签到</a></li><li class="sidebar-sub-header level2"><a href="/pages/1ce2e2/#_12、uv统计" class="sidebar-link">12、UV统计</a></li></ul></li><li><a href="/pages/62a615/" class="sidebar-link">elasticsearch</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-1-了解es" class="sidebar-link">1.1.了解ES</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-2-倒排索引" class="sidebar-link">1.2.倒排索引</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-3-es的一些概念" class="sidebar-link">1.3.es的一些概念</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-4-安装es、kibana" class="sidebar-link">1.4.安装es、kibana</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_2-1-mapping映射属性" class="sidebar-link">2.1.mapping映射属性</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_2-2-索引库的crud" class="sidebar-link">2.2.索引库的CRUD</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-1-新增文档" class="sidebar-link">3.1.新增文档</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-2-查询文档" class="sidebar-link">3.2.查询文档</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-3-删除文档" class="sidebar-link">3.3.删除文档</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-4-修改文档" class="sidebar-link">3.4.修改文档</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-5-总结" class="sidebar-link">3.5.总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-0-导入demo工程" class="sidebar-link">4.0.导入Demo工程</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-1-创建索引库" class="sidebar-link">4.1.创建索引库</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-2-删除索引库" class="sidebar-link">4.2.删除索引库</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-3-判断索引库是否存在" class="sidebar-link">4.3.判断索引库是否存在</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-4-总结" class="sidebar-link">4.4.总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_5-1-新增文档" class="sidebar-link">5.1.新增文档</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_5-2-查询文档" class="sidebar-link">5.2.查询文档</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_5-3-删除文档" class="sidebar-link">5.3.删除文档</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_5-4-修改文档" class="sidebar-link">5.4.修改文档</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_5-5-批量导入文档" class="sidebar-link">5.5.批量导入文档</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_5-6-小结" class="sidebar-link">5.6.小结</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-1-dsl查询分类" class="sidebar-link">1.1.DSL查询分类</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-2-全文检索查询" class="sidebar-link">1.2.全文检索查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-3-精准查询" class="sidebar-link">1.3.精准查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-4-地理坐标查询" class="sidebar-link">1.4.地理坐标查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-5-复合查询" class="sidebar-link">1.5.复合查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_2-1-排序" class="sidebar-link">2.1.排序</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_2-2-分页" class="sidebar-link">2.2.分页</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_2-3-高亮" class="sidebar-link">2.3.高亮</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_2-4-总结" class="sidebar-link">2.4.总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-1-快速入门" class="sidebar-link">3.1.快速入门</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-2-match查询" class="sidebar-link">3.2.match查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-3-精确查询" class="sidebar-link">3.3.精确查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-4-布尔查询" class="sidebar-link">3.4.布尔查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-5-排序、分页" class="sidebar-link">3.5.排序、分页</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-6-高亮" class="sidebar-link">3.6.高亮</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-1-酒店搜索和分页" class="sidebar-link">4.1.酒店搜索和分页</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-2-酒店结果过滤" class="sidebar-link">4.2.酒店结果过滤</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-3-我周边的酒店" class="sidebar-link">4.3.我周边的酒店</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-4-酒店竞价排名" class="sidebar-link">4.4.酒店竞价排名</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-1-聚合的种类" class="sidebar-link">1.1.聚合的种类</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-2-dsl实现聚合" class="sidebar-link">1.2.DSL实现聚合</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_1-3-restapi实现聚合" class="sidebar-link">1.3.RestAPI实现聚合</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_2-1-拼音分词器" class="sidebar-link">2.1.拼音分词器</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_2-2-自定义分词器" class="sidebar-link">2.2.自定义分词器</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_2-3-自动补全查询" class="sidebar-link">2.3.自动补全查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_2-4-实现酒店搜索框自动补全" class="sidebar-link">2.4.实现酒店搜索框自动补全</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-1-思路分析" class="sidebar-link">3.1.思路分析</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_3-2-实现数据同步" class="sidebar-link">3.2.实现数据同步</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-1-搭建es集群" class="sidebar-link">4.1.搭建ES集群</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-2-集群脑裂问题" class="sidebar-link">4.2.集群脑裂问题</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-3-集群分布式存储" class="sidebar-link">4.3.集群分布式存储</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-4-集群分布式查询" class="sidebar-link">4.4.集群分布式查询</a></li><li class="sidebar-sub-header level2"><a href="/pages/62a615/#_4-5-集群故障转移" class="sidebar-link">4.5.集群故障转移</a></li></ul></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>数据库</span></li><li data-v-06225672><span data-v-06225672>数据库</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://www.aismy.top" target="_blank" title="作者" class="beLink" data-v-06225672>Aismy</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2021-10-15</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">MySQL<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="一、sql"><a href="#一、sql" class="header-anchor">#</a> 一、SQL</h1> <h2 id="_1-1-sql分类"><a href="#_1-1-sql分类" class="header-anchor">#</a> 1.1 SQL分类</h2> <p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。</p> <ul><li><code>DDL</code>: 数据定义语言，用来定义<strong>数据库对象</strong>（数据库、表、字段）</li> <li><code>DML</code>: 数据操作语言，用来对数据库表中的<strong>数据</strong>进行增删改</li> <li><code>DQL</code>: 数据查询语言，用来查询数据库中表的<strong>记录</strong></li> <li><code>DCL</code>: 数据控制语言，用来创建数据库<strong>用户</strong>、控制数据库的<strong>控制权限</strong></li></ul> <h2 id="_1-2-ddl-数据定义语言"><a href="#_1-2-ddl-数据定义语言" class="header-anchor">#</a> 1. 2 DDL（数据定义语言）</h2> <p>Data Definition Language，数据定义语言，用来定义数据库对象(数据库，表，字段)</p> <h3 id="_1-2-1-数据库操作"><a href="#_1-2-1-数据库操作" class="header-anchor">#</a> 1.2.1 数据库操作</h3> <p>(1)查询所有数据库：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>show databases;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><img src="http://img.aismy.top/img/image-20220420160541116.png" alt="image-20220420160541116" style="zoom:67%;"> <p>(2)查询当前数据库：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>select database(); 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(3)创建数据库：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>可选项 IF NOT EXISTS 代表，只有想要创建的数据库不存在时才会才会执行创建操作，操作(如果不
加该参数项，若创建的数据库已存在则会报错)。</p></blockquote> <p>(4)删除数据库：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>DROP DATABASE [ IF EXISTS ] 数据库名;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(5)使用数据库：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>USE 数据库名;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>注意事项</strong></p> <ul><li>UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</li></ul> <h3 id="_1-2-2表操作"><a href="#_1-2-2表操作" class="header-anchor">#</a> 1.2.2表操作</h3> <h4 id="查询创建"><a href="#查询创建" class="header-anchor">#</a> 查询创建</h4> <p>(1)查询<strong>当前数据库</strong>所有表：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SHOW TABLES;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(2)查询表结构：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>DESC 表名;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通过这条指令，我们可以查看到指定表的字段，字段的类型、是否可以为NULL，是否存在默认值等信
息。</p> <img src="http://img.aismy.top/img/image-20220420161255074.png" alt="image-20220420161255074" style="zoom:67%;">
(3)查询指定表的建表语句：
<div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SHOW CREATE TABLE 表名;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220420161827935.png" alt="image-20220420161827935"></p> <p>(4)创建表：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>CREATE TABLE 表名(
	字段1 字段1类型 [COMMENT 字段1注释],
	字段2 字段2类型 [COMMENT 字段2注释],
	字段3 字段3类型 [COMMENT 字段3注释],
	...
	字段n 字段n类型 [COMMENT 字段n注释]
)[ COMMENT 表注释 ];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>注意: [...] 内为可选参数，最后一个字段	逗号</p></blockquote> <p>比如，我们创建一张表 tb_user ，对应的结构如下，那么建表语句为：</p> <p><img src="http://img.aismy.top/img/image-20220420161912220.png" alt="image-20220420161912220"></p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>create table tb_user(
    id int comment '编号',
    name varchar(50) comment '姓名',
    age int comment '年龄',
    gender varchar(1) comment '性别'
) comment '用户表';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h4> <blockquote><p>在上述的建表语句中，我们在指定字段的数据类型时，用到了int ，varchar，那么在MySQL中除了
以上的数据类型，还有哪些常见的数据类型呢？ 接下来,我们就来详细介绍一下MySQL的数据类型。
MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p></blockquote> <h5 id="整型"><a href="#整型" class="header-anchor">#</a> 整型</h5> <table><thead><tr><th>类型名称</th> <th>取值范围</th> <th>大小</th></tr></thead> <tbody><tr><td>TINYINT</td> <td>-128〜127</td> <td>1个字节</td></tr> <tr><td>SMALLINT</td> <td>-32768〜32767</td> <td>2个宇节</td></tr> <tr><td>MEDIUMINT</td> <td>-8388608〜8388607</td> <td>3个字节</td></tr> <tr><td>INT (INTEGHR)</td> <td>-2147483648〜2147483647</td> <td>4个字节</td></tr> <tr><td>BIGINT</td> <td>-9223372036854775808〜9223372036854775807</td> <td>8个字节</td></tr></tbody></table> <p>无符号在数据类型后加 unsigned 关键字。</p> <p>选择适合的数据类型：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大
age tinyint unsigned
2). 分数 -- 总分100分, 最多出现一位小数
score double(4,1)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>(2) 字符串类型</p> <h5 id="浮点型"><a href="#浮点型" class="header-anchor">#</a> 浮点型</h5> <table><thead><tr><th>类型名称</th> <th>说明</th> <th>存储需求</th></tr></thead> <tbody><tr><td>FLOAT</td> <td>单精度浮点数</td> <td>4 个字节</td></tr> <tr><td>DOUBLE</td> <td>双精度浮点数</td> <td>8 个字节</td></tr> <tr><td>DECIMAL (M, D)，DEC</td> <td>压缩的“严格”定点数</td> <td>M+2 个字节</td></tr></tbody></table> <h5 id="日期和时间"><a href="#日期和时间" class="header-anchor">#</a> 日期和时间</h5> <table><thead><tr><th>类型名称</th> <th>日期格式</th> <th>日期范围</th> <th>存储需求</th></tr></thead> <tbody><tr><td>YEAR</td> <td>YYYY</td> <td>1901 ~ 2155</td> <td>1 个字节</td></tr> <tr><td>TIME</td> <td>HH:MM:SS</td> <td>-838:59:59 ~ 838:59:59</td> <td>3 个字节</td></tr> <tr><td>DATE</td> <td>YYYY-MM-DD</td> <td>1000-01-01 ~ 9999-12-3</td> <td>3 个字节</td></tr> <tr><td>DATETIME</td> <td>YYYY-MM-DD HH:MM:SS</td> <td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td> <td>8 个字节</td></tr> <tr><td>TIMESTAMP</td> <td>YYYY-MM-DD HH:MM:SS</td> <td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td> <td>4 个字节</td></tr></tbody></table> <h5 id="字符串"><a href="#字符串" class="header-anchor">#</a> 字符串</h5> <table><thead><tr><th>类型名称</th> <th>说明</th> <th>存储需求</th></tr></thead> <tbody><tr><td>CHAR(M)</td> <td>固定长度非二进制字符串</td> <td>M 字节，1&lt;=M&lt;=255</td></tr> <tr><td>VARCHAR(M)</td> <td>变长非二进制字符串</td> <td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td></tr> <tr><td>TINYTEXT</td> <td>非常小的非二进制字符串</td> <td>L+1字节，在此，L&lt;2^8</td></tr> <tr><td>TEXT</td> <td>小的非二进制字符串</td> <td>L+2字节，在此，L&lt;2^16</td></tr> <tr><td>MEDIUMTEXT</td> <td>中等大小的非二进制字符串</td> <td>L+3字节，在此，L&lt;2^24</td></tr> <tr><td>LONGTEXT</td> <td>大的非二进制字符串</td> <td>L+4字节，在此，L&lt;2^32</td></tr> <tr><td>ENUM</td> <td>枚举类型，只能有一个枚举字符串值</td> <td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr> <tr><td>SET</td> <td>一个设置，字符串对象可以有零个或 多个SET成员</td> <td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table> <blockquote><p><code>char</code>与 <code>varchar</code>都可以描述字符串，<code>char</code>是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。而<code>varchar</code>是变长字符串，指定的长度为最大占用长度 。相对来说，char的性 能会更高些。</p> <p>VARCHAR节省了存储空间但是，由于行是可变的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。</p></blockquote> <blockquote><p><code>BLOB 和 TEXT</code></p> <p>BLOB和TEXT都是为存储很大的数据而设计的数据类型，分别采用二进制和字符方式存储。与其他类型不同，MySQL把每个BLOB和TEXT值当做一个独立的对象去处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length个字节而不是整个字符串做排序。同样的，MySQL也不能将BLOB或TEXT列全部长度的字符串进行索引。</p></blockquote> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>如：
1). 用户名 username ------&gt; 长度不定, 最长不会超过50
username varchar(50)
2). 性别 gender ---------&gt; 存储值, 不是男,就是女
gender char(1)
3). 手机号 phone --------&gt; 固定长度为11
phone char(11)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h5 id="二进制类型"><a href="#二进制类型" class="header-anchor">#</a> 二进制类型</h5> <table><thead><tr><th>类型名称</th> <th>说明</th> <th>存储需求</th></tr></thead> <tbody><tr><td>BIT(M)</td> <td>位字段类型</td> <td>大约 (M+7)/8 字节</td></tr> <tr><td>BINARY(M)</td> <td>固定长度二进制字符串</td> <td>M 字节</td></tr> <tr><td>VARBINARY (M)</td> <td>可变长度二进制字符串</td> <td>M+1 字节</td></tr> <tr><td>TINYBLOB (M)</td> <td>非常小的BLOB</td> <td>L+1 字节，在此，L&lt;2^8</td></tr> <tr><td>BLOB (M)</td> <td>小 BLOB</td> <td>L+2 字节，在此，L&lt;2^16</td></tr> <tr><td>MEDIUMBLOB (M)</td> <td>中等大小的BLOB</td> <td>L+3 字节，在此，L&lt;2^24</td></tr> <tr><td>LONGBLOB (M)</td> <td>非常大的BLOB</td> <td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table> <h4 id="修改"><a href="#修改" class="header-anchor">#</a> 修改</h4> <p>(1)添加字段：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>例：为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20)</p> <p><code>ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称';</code></p> <p>(2)修改数据类型：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度); 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(3)修改字段名和字段类型：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ]; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>例：将emp表的nickname字段修改为username，类型为varchar(30)
<code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称';</code></p> <p>(4)删除字段：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code> ALTER TABLE 表名 DROP 字段名; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(5)修改表名：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>ALTER TABLE 表名 RENAME TO 新表名; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="删除"><a href="#删除" class="header-anchor">#</a> 删除</h4> <p>(1)删除表：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>DROP TABLE [ IF EXISTS ] 表名; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(2)删除表，并重新创建该表：(相当于清空表中数据)</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>TRUNCATE TABLE 表名;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_1-3-dml-数据操作语言"><a href="#_1-3-dml-数据操作语言" class="header-anchor">#</a> 1.3 DML（数据操作语言）</h2> <p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进
行增、删、改操作。</p> <ul><li>添加数据（INSERT）</li> <li>修改数据（UPDATE）</li> <li>删除数据（DELETE）</li></ul> <h4 id="添加数据"><a href="#添加数据" class="header-anchor">#</a> 添加数据</h4> <p>(1)给指定字段添加数据</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>INSERT INTO 表名 (字段名1, 字段名2, ...) 
VALUES (值1, 值2, ...);

#若给全部字段添加数据，则可忽略字段名，但valuse的值顺序必须与数据库字段顺序一致：
INSERT INTO 表名 VALUES (值1, 值2, ...);

#批量添加数据
INSERT INTO 表名 VALUES (值1, 值2, ...),
(值1, 值2, ...), 
(值1, 值2, ...) ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>注意事项</p> <ul><li>字符串和日期类型数据应该包含在引号中</li> <li>插入的数据大小应该在字段的规定范围内</li> <li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li></ul> <h4 id="更新和删除数据"><a href="#更新和删除数据" class="header-anchor">#</a> 更新和删除数据</h4> <p>(1)修改数据：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>注意事项:
修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p></blockquote> <p>(2)删除数据：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>DELETE FROM 表名 [ WHERE 条件 ] ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_1-4-dql-数据查询语言"><a href="#_1-4-dql-数据查询语言" class="header-anchor">#</a> 1.4 DQL（数据查询语言）</h2> <p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记
录</p> <p>查询关键字: SELECT</p> <h3 id="_1-4-1-基本语法"><a href="#_1-4-1-基本语法" class="header-anchor">#</a> 1.4.1 基本语法</h3> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT
	字段列表
FROM
	表名字段
WHERE
	条件列表
GROUP BY
	分组字段列表
HAVING
	分组后的条件列表
ORDER BY
	排序字段列表
LIMIT
	分页参数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li>基本查询（不带任何条件）</li> <li>条件查询（WHERE）</li> <li>聚合函数（count、max、min、avg、sum）</li> <li>分组查询（group by）</li> <li>排序查询（order by）</li> <li>分页查询（limit）</li></ul> <h3 id="_1-4-2基础查询"><a href="#_1-4-2基础查询" class="header-anchor">#</a> 1.4.2基础查询</h3> <p>(1)查询多个字段：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段1, 字段2, 字段3 ... FROM 表名 ; 

#   *号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。
SELECT * FROM 表名 ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>(2)设置别名：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名; 
# as可以省略
SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>(3)去除重复记录</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT DISTINCT 字段列表 FROM 表名;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_1-4-3条件查询"><a href="#_1-4-3条件查询" class="header-anchor">#</a> 1.4.3条件查询</h3> <p>语法：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段列表 FROM 表名 WHERE 条件列表 ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>条件：</p> <table><thead><tr><th>比较运算符</th> <th>功能</th></tr></thead> <tbody><tr><td>&gt;</td> <td>大于</td></tr> <tr><td>&gt;=</td> <td>大于等于</td></tr> <tr><td>&lt;</td> <td>小于</td></tr> <tr><td>&lt;=</td> <td>小于等于</td></tr> <tr><td>=</td> <td>等于</td></tr> <tr><td>&lt;&gt; 或 !=</td> <td>不等于</td></tr> <tr><td>BETWEEN ... AND ...</td> <td>在某个范围内（含最小、最大值）</td></tr> <tr><td>IN(...)</td> <td>在in之后的列表中的值，多选一</td></tr> <tr><td>LIKE 占位符</td> <td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr> <tr><td>IS NULL</td> <td>是NULL</td></tr></tbody></table> <table><thead><tr><th>逻辑运算符</th> <th>功能</th></tr></thead> <tbody><tr><td>AND 或 &amp;&amp;</td> <td>并且（多个条件同时成立）</td></tr> <tr><td>OR 或 ||</td> <td>或者（多个条件任意一个成立）</td></tr> <tr><td>NOT 或 !</td> <td>非，不是</td></tr></tbody></table> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 年龄等于30
select * from employee where age = 30;
-- 年龄小于30
select * from employee where age &lt; 30;
-- 小于等于
select * from employee where age &lt;= 30;
-- 没有身份证
select * from employee where idcard is null or idcard = '';
-- 有身份证
select * from employee where idcard;
select * from employee where idcard is not null;
-- 不等于
select * from employee where age != 30;
-- 年龄在20到30之间
select * from employee where age between 20 and 30;
select * from employee where age &gt;= 20 and age &lt;= 30;
-- 下面语句不报错，但查不到任何信息
select * from employee where age between 30 and 20;
-- 性别为女且年龄小于30
select * from employee where age &lt; 30 and gender = '女';
-- 年龄等于25或30或35
select * from employee where age = 25 or age = 30 or age = 35;
select * from employee where age in (25, 30, 35);
-- 姓名为两个字
select * from employee where name like '__';
-- 身份证最后为X
select * from employee where idcard like '%X';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h3 id="_1-4-4聚合查询-聚合函数"><a href="#_1-4-4聚合查询-聚合函数" class="header-anchor">#</a> 1.4.4聚合查询（聚合函数）</h3> <blockquote><p>将一列数据作为一个整体，进行纵向计算 。</p></blockquote> <p>常见聚合函数：</p> <table><thead><tr><th>函数</th> <th>功能</th></tr></thead> <tbody><tr><td>count</td> <td>统计数量</td></tr> <tr><td>max</td> <td>最大值</td></tr> <tr><td>min</td> <td>最小值</td></tr> <tr><td>avg</td> <td>平均值</td></tr> <tr><td>sum</td> <td>求和</td></tr></tbody></table> <p>语法：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 聚合函数(字段列表) FROM 表名 ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>注意 : NULL值是不参与所有聚合函数运算的。</p></blockquote> <p>例：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>#统计该企业员工数量
select count(*) from emp; -- 统计的是总记录数
select count(idcard) from emp; -- 统计的是idcard字段不为null的记录数
#统计该企业员工的平均年龄
select avg(age) from emp; 
#统计该企业员工的最大年龄
select max(age) from emp; 
#统计该企业员工的最小年龄
select min(age) from emp; 
#统计西安地区员工的年龄之和
select sum(age) from emp where workaddress = '西安'; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字/字符串)的形式进行统计
查询  count(*) 、count(字段)、 count(1)</p></blockquote> <h3 id="_1-4-5-分组查询"><a href="#_1-4-5-分组查询" class="header-anchor">#</a> 1.4.5 分组查询</h3> <p>语法：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段列表 
FROM 表名 
[ WHERE 条件 ]
GROUP BY 分组字段名 
[ HAVING 分组后过滤条件 ];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>where</code>和<code>having</code> 的区别：</p> <ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li> <li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）
select count(*) from employee group by gender;
-- 根据性别分组，统计男性和女性数量
select gender, count(*) from employee group by gender;
-- 根据性别分组，统计男性和女性的平均年龄
select gender, avg(age) from employee group by gender;
-- 年龄小于45，并根据工作地址分组
select workaddress, count(*) from employee where age &lt; 45 group by workaddress;
-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址
select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>注意事项:</p> <ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li> <li>分组之后，查询的字段一般为<code>聚合函数</code>和<code>分组字段</code>，查询其他字段无任何意义</li> <li>支持多字段分组, 具体语法为 : group by columnA,columnB</li></ul></blockquote> <h3 id="_1-4-6-排序查询"><a href="#_1-4-6-排序查询" class="header-anchor">#</a> 1.4.6 排序查询</h3> <p>语法：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>排序方式：</p> <ul><li>ASC: 升序（默认）</li> <li>DESC: 降序</li></ul> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 根据年龄升序排序
SELECT * FROM employee ORDER BY age ASC;
SELECT * FROM employee ORDER BY age;
-- 两字段排序，根据年龄升序排序，入职时间降序排序
SELECT * FROM employee ORDER BY age ASC, entrydate DESC;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>注意事项：</p> <ul><li>如果是升序, 可以不指定排序方式ASC ;</li> <li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;</li></ul></blockquote> <h3 id="_1-4-7-分页查询"><a href="#_1-4-7-分页查询" class="header-anchor">#</a> 1.4.7 分页查询</h3> <p>语法：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 查询第一页数据，展示10条
SELECT * FROM employee LIMIT 0, 10;
-- 查询第二页
SELECT * FROM employee LIMIT 10, 10;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>注意事项</p> <ul><li>起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数</li> <li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li> <li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul></blockquote> <h3 id="_1-4-8-dql执行顺序"><a href="#_1-4-8-dql执行顺序" class="header-anchor">#</a> 1.4.8 DQL执行顺序</h3> <img src="http://img.aismy.top/img/image-20220420172740921.png" alt="image-20220420172740921" style="zoom:67%;"> <p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p> <blockquote><p>因此在<code>select</code>后面为字段所起的别名，不能在<code>where</code>语句中使用，而<code>from</code>中为表所起的别名可以在<code>where</code>语句中使用</p></blockquote> <h2 id="_1-5-dcl"><a href="#_1-5-dcl" class="header-anchor">#</a> 1.5 DCL</h2> <p>DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访
问权限。</p> <h3 id="_1-5-1-管理用户"><a href="#_1-5-1-管理用户" class="header-anchor">#</a> 1.5.1 管理用户</h3> <p>(1)查询用户：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>select * from mysql.user; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>查询的结果如下:</p> <p><img src="http://img.aismy.top/img/image-20220420173148852.png" alt="image-20220420173148852"></p> <blockquote><p>其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以
远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一
个用户。</p></blockquote> <p>(2)创建用户:</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(3)修改用户密码：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(4)删除用户：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>DROP USER '用户名'@'主机名';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 创建用户test，只能在当前主机localhost访问
create user 'test'@'localhost' identified by '123456';
-- 创建用户test，能在任意主机访问
create user 'test'@'%' identified by '123456';
create user 'test' identified by '123456';
-- 修改密码
alter user 'test'@'localhost' identified with mysql_native_password by '1234';
-- 删除用户
drop user 'test'@'localhost';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h5 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h5> <ul><li>主机名可以使用 % 通配</li></ul> <h3 id="_1-5-2-权限控制"><a href="#_1-5-2-权限控制" class="header-anchor">#</a> 1.5.2 权限控制</h3> <p>常用权限：</p> <table><thead><tr><th>权限</th> <th>说明</th></tr></thead> <tbody><tr><td>ALL, ALL PRIVILEGES</td> <td>所有权限</td></tr> <tr><td>SELECT</td> <td>查询数据</td></tr> <tr><td>INSERT</td> <td>插入数据</td></tr> <tr><td>UPDATE</td> <td>修改数据</td></tr> <tr><td>DELETE</td> <td>删除数据</td></tr> <tr><td>ALTER</td> <td>修改表</td></tr> <tr><td>DROP</td> <td>删除数据库/表/视图</td></tr> <tr><td>CREATE</td> <td>创建数据库/表</td></tr></tbody></table> <p>查询权限：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SHOW GRANTS FOR '用户名'@'主机名';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>授予权限：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>撤销权限：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>注意事项</strong></p> <ul><li>多个权限用逗号分隔</li> <li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul> <h1 id="二、函数"><a href="#二、函数" class="header-anchor">#</a> 二、函数</h1> <blockquote><p>函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中
已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可。</p></blockquote> <ul><li>字符串函数</li> <li>数值函数</li> <li>日期函数</li> <li>流程函数</li></ul> <h2 id="_2-1-字符串函数"><a href="#_2-1-字符串函数" class="header-anchor">#</a> 2.1 字符串函数</h2> <p>常用函数：</p> <table><thead><tr><th>函数</th> <th>功能</th></tr></thead> <tbody><tr><td>CONCAT(s1, s2, ..., sn)</td> <td>字符串拼接，将s1, s2, ..., sn拼接成一个字符串</td></tr> <tr><td>LOWER(str)</td> <td>将字符串全部转为小写</td></tr> <tr><td>UPPER(str)</td> <td>将字符串全部转为大写</td></tr> <tr><td>LPAD(str, n, pad)</td> <td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr> <tr><td>RPAD(str, n, pad)</td> <td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr> <tr><td>TRIM(str)</td> <td>去掉字符串头部和尾部的空格</td></tr> <tr><td>SUBSTRING(str, start, len)</td> <td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table> <p>使用示例：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 拼接
SELECT CONCAT('Hello', 'World');
-- 小写
SELECT LOWER('Hello');
-- 大写
SELECT UPPER('Hello');
-- 左填充
SELECT LPAD('01', 5, '-');
-- 右填充
SELECT RPAD('01', 5, '-');
-- 去除空格
SELECT TRIM(' Hello World ');
-- 切片（起始索引为1）
SELECT SUBSTRING('Hello World', 1, 5);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_2-2-数值函数"><a href="#_2-2-数值函数" class="header-anchor">#</a> 2.2 数值函数</h2> <p>常见函数：</p> <table><thead><tr><th>函数</th> <th>功能</th></tr></thead> <tbody><tr><td>CEIL(x)</td> <td>向上取整</td></tr> <tr><td>FLOOR(x)</td> <td>向下取整</td></tr> <tr><td>MOD(x, y)</td> <td>返回x/y的模</td></tr> <tr><td>RAND()</td> <td>返回0~1内的随机数</td></tr> <tr><td>ROUND(x, y)</td> <td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table> <h2 id="_2-3-日期函数"><a href="#_2-3-日期函数" class="header-anchor">#</a> 2.3 日期函数</h2> <p>常用函数：</p> <table><thead><tr><th>函数</th> <th>功能</th></tr></thead> <tbody><tr><td>CURDATE()</td> <td>返回当前日期</td></tr> <tr><td>CURTIME()</td> <td>返回当前时间</td></tr> <tr><td>NOW()</td> <td>返回当前日期和时间</td></tr> <tr><td>YEAR(date)</td> <td>获取指定date的年份</td></tr> <tr><td>MONTH(date)</td> <td>获取指定date的月份</td></tr> <tr><td>DAY(date)</td> <td>获取指定date的日期</td></tr> <tr><td>DATE_ADD(date, INTERVAL expr type)</td> <td>返回一个日期/时间值加上一个时间间隔expr后的时间值</td></tr> <tr><td>DATEDIFF(date1, date2)</td> <td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- DATE_ADD
SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_2-4-流程函数"><a href="#_2-4-流程函数" class="header-anchor">#</a> 2.4 流程函数</h2> <p>常用函数：</p> <table><thead><tr><th>函数</th> <th>功能</th></tr></thead> <tbody><tr><td>IF(value, t, f)</td> <td>如果value为true，则返回t，否则返回f</td></tr> <tr><td>IFNULL(value1, value2)</td> <td>如果value1不为空，返回value1，否则返回value2</td></tr> <tr><td>CASE WHEN [ val1 ] THEN [ res1 ] ... ELSE [ default ] END</td> <td>如果val1为true，返回res1，... 否则返回default默认值</td></tr> <tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] ... ELSE [ default ] END</td> <td>如果expr的值等于val1，返回res1，... 否则返回default默认值</td></tr></tbody></table> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>select
	name,
	(case when age &gt; 30 then '中年' else '青年' end)
from employee;
select
	name,
	(case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址'
from employee;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h1 id="三、约束"><a href="#三、约束" class="header-anchor">#</a> 三、约束</h1> <blockquote><p>**概念：**约束是作用于表中字段上的规则，用于限制存储在表中的数据。
**目的：**保证数据库中数据的正确、有效性和完整性。</p></blockquote> <table><thead><tr><th>约束</th> <th>描述</th> <th>关键字</th></tr></thead> <tbody><tr><td>非空约束</td> <td>限制该字段的数据不能为null</td> <td>NOT NULL</td></tr> <tr><td>唯一约束</td> <td>保证该字段的所有数据都是唯一、不重复的</td> <td>UNIQUE</td></tr> <tr><td>主键约束</td> <td>主键是一行数据的唯一标识，要求非空且唯一</td> <td>PRIMARY KEY</td></tr> <tr><td>默认约束</td> <td>保存数据时，如果未指定该字段的值，则采用默认值</td> <td>DEFAULT</td></tr> <tr><td>检查约束（8.0.1版本后）</td> <td>保证字段值满足某一个条件</td> <td>CHECK</td></tr> <tr><td>外键约束</td> <td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td> <td>FOREIGN KEY</td></tr></tbody></table> <blockquote><p>约束是作用于表中<strong>字段</strong>上的，可以再创建表/修改表的时候添加约束。</p></blockquote> <h2 id="_3-1-常用约束"><a href="#_3-1-常用约束" class="header-anchor">#</a> 3.1 常用约束</h2> <table><thead><tr><th>约束条件</th> <th>关键字</th></tr></thead> <tbody><tr><td>主键</td> <td>PRIMARY KEY</td></tr> <tr><td>自动增长</td> <td>AUTO_INCREMENT</td></tr> <tr><td>不为空</td> <td>NOT NULL</td></tr> <tr><td>唯一</td> <td>UNIQUE</td></tr> <tr><td>逻辑条件</td> <td>CHECK</td></tr> <tr><td>默认值</td> <td>DEFAULT</td></tr></tbody></table> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>create table user(
	id int primary key auto_increment,
	name varchar(10) not null unique,
	age int check(age &gt; 0 and age &lt; 120),
	status char(1) default '1',
	gender char(1)
);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_3-2-外键约束"><a href="#_3-2-外键约束" class="header-anchor">#</a> 3.2 外键约束</h2> <p>添加外键：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>CREATE TABLE 表名(
	字段名 字段类型,
	...
	[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)
);
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);

-- 例子
alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>删除外键：
<code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p> <h4 id="删除-更新行为"><a href="#删除-更新行为" class="header-anchor">#</a> 删除/更新行为</h4> <table><thead><tr><th>行为</th> <th>说明</th></tr></thead> <tbody><tr><td>NO ACTION</td> <td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</td></tr> <tr><td>RESTRICT</td> <td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）</td></tr> <tr><td>CASCADE</td> <td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td></tr> <tr><td>SET NULL</td> <td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr> <tr><td>SET DEFAULT</td> <td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table> <p>更改删除/更新行为：
<code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p> <h1 id="四、多表查询"><a href="#四、多表查询" class="header-anchor">#</a> 四、多表查询</h1> <h2 id="_4-1-概述"><a href="#_4-1-概述" class="header-anchor">#</a> 4.1 概述</h2> <blockquote><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结
构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种:</p></blockquote> <ul><li>一对多（多对一）</li> <li>多对多</li> <li>一对一</li></ul> <h3 id="_1-一对多"><a href="#_1-一对多" class="header-anchor">#</a> 1. 一对多</h3> <p>案例：部门与员工
关系：一个部门对应多个员工，一个员工对应一个部门
实现：在多的一方建立外键，指向一的一方的主键</p> <h3 id="_2-多对多"><a href="#_2-多对多" class="header-anchor">#</a> 2. 多对多</h3> <p>案例：学生与课程
关系：一个学生可以选多门课程，一门课程也可以供多个学生选修
实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p> <h3 id="_3-一对一"><a href="#_3-一对一" class="header-anchor">#</a> 3. 一对一</h3> <p>案例：用户与用户详情
关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率
实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p> <h2 id="_4-2-连接查询"><a href="#_4-2-连接查询" class="header-anchor">#</a> 4.2 连接查询</h2> <p>连接查询分为：</p> <ul><li>内连接：相当于查询A、B交集部分数据</li> <li>外连接：
<ul><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li> <li>右外连接：查询右表所有数据，以及两张表交集部分数据</li></ul></li> <li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul> <h3 id="_4-2-1内连接"><a href="#_4-2-1内连接" class="header-anchor">#</a> 4.2.1内连接</h3> <p>内连接查询的是两张表交集部分的数据。</p> <p>内连接的语法分为两种: <code>隐式内连接</code>、<code>显式内连接</code>。</p> <p>(1)隐式内连接:</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(2)显式内连接:</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>显式性能比隐式高</p></blockquote> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 查询员工姓名，及关联的部门的名称
-- 隐式
select e.name, d.name from employee as e, dept as d where e.dept = d.id;
-- 显式
select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_4-2-2-外连接"><a href="#_4-2-2-外连接" class="header-anchor">#</a> 4.2.2 外连接</h3> <blockquote><p>外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：</p></blockquote> <p>(1)左外连接：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>查询左表所有数据，以及两张表交集部分数据</p> <p>(2)右外连接：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>查询右表所有数据，以及两张表交集部分数据</p> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 左
select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id; 
-- 右
select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>左连接可以查询到没有dept的employee(即查出所有员工)，右连接可以查询到没有employee的dept（即查出所有部门）</p></blockquote> <h3 id="_4-2-3-自连接"><a href="#_4-2-3-自连接" class="header-anchor">#</a> 4.2.3 自连接</h3> <h4 id="自连接查询"><a href="#自连接查询" class="header-anchor">#</a> 自连接查询</h4> <blockquote><p>当前表与自身的连接查询，自连接必须使用表别名，要不然我们不清楚所指定的条件、返回的字段，到底
是哪一张表的字段。</p></blockquote> <p>语法：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>自连接查询，可以是内连接查询，也可以是外连接查询</p> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 查询员工及其所属领导的名字(员工和领导都在employee表中)
select a.name, b.name from employee a, employee b where a.manager = b.id;
-- 没有领导的也查询出来
select a.name, b.name from employee a left join employee b on a.manager = b.id;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="联合查询"><a href="#联合查询" class="header-anchor">#</a> 联合查询</h4> <p>把多次查询的结果合并，形成一个新的查询集</p> <p>语法：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT 字段列表 FROM 表A ...
UNION [ALL]
SELECT 字段列表 FROM 表B ...
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>案例：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>#将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来.
select * from emp where salary &lt; 5000
union 
select * from emp where age &gt; 50;

#也可以使用or
select * from emp where salary &lt; 5000 or age &gt; 50;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>注意事项:</p> <ul><li>UNION ALL 会有重复结果，UNION 不会</li> <li><code>联合查询</code>比使用<code>or</code>效率高，不会使索引失效</li> <li>如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报
错。</li></ul></blockquote> <h2 id="_4-3子查询"><a href="#_4-3子查询" class="header-anchor">#</a> 4.3子查询</h2> <p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。</p> <p><strong>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</strong></p> <p>根据子查询结果可以分为：</p> <ul><li>标量子查询（子查询结果为单个值）</li> <li>列子查询（子查询结果为一列）</li> <li>行子查询（子查询结果为一行）</li> <li>表子查询（子查询结果为多行多列）</li></ul> <p>根据子查询位置可分为：</p> <ul><li>WHERE 之后</li> <li>FROM 之后</li> <li>SELECT 之后</li></ul> <h3 id="_4-3-1-标量子查询"><a href="#_4-3-1-标量子查询" class="header-anchor">#</a> 4.3.1 标量子查询</h3> <p>子查询返回的结果是单个值（数字、字符串、日期等）。
常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;=</p> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 查询销售部所有员工
select id from dept where name = '销售部';
-- 根据销售部部门ID，查询员工信息
select * from employee where dept = 4;
-- 合并（子查询）
select * from employee where dept = (select id from dept where name = '销售部');

-- 查询xxx入职之后的员工信息
select * from employee where entrydate &gt; (select entrydate from employee where name = 'xxx');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_4-3-2-列子查询"><a href="#_4-3-2-列子查询" class="header-anchor">#</a> 4.3.2 列子查询</h3> <p>返回的结果是一列（可以是多行）。</p> <p>常用操作符：</p> <table><thead><tr><th>操作符</th> <th>描述</th></tr></thead> <tbody><tr><td>IN</td> <td>在指定的集合范围内，多选一</td></tr> <tr><td>NOT IN</td> <td>不在指定的集合范围内</td></tr> <tr><td>ANY</td> <td>子查询返回列表中，有任意一个满足即可</td></tr> <tr><td>SOME</td> <td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr> <tr><td>ALL</td> <td>子查询返回列表的所有值都必须满足</td></tr></tbody></table> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 查询销售部和市场部的所有员工信息
select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部');
-- 查询比财务部所有人工资都高的员工信息
select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = '财务部'));
-- 查询比研发部任意一人工资高的员工信息
select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = '研发部'));
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_4-3-3-行子查询"><a href="#_4-3-3-行子查询" class="header-anchor">#</a> 4.3.3 行子查询</h3> <p>返回的结果是一行（可以是多列）。多列（多个属性值）
常用操作符：=, &lt;, &gt;, IN, NOT IN</p> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 查询与xxx的薪资及直属领导相同的员工信息
select * from employee where (salary, manager) = (12500, 1);
select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_4-3-4-表子查询"><a href="#_4-3-4-表子查询" class="header-anchor">#</a> 4.3.4 表子查询</h3> <p>返回的结果是多行多列
常用操作符：IN</p> <p>例子：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 查询与xxx1，xxx2的职位和薪资相同的员工
select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2');
-- 查询入职日期是2006-01-01之后的员工，及其部门信息
select e.*, d.* from (select * from employee where entrydate &gt; '2006-01-01') as e left join dept as d on e.dept = d.id;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h1 id="五、事务"><a href="#五、事务" class="header-anchor">#</a> 五、事务</h1> <p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p> <blockquote><p>注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。</p></blockquote> <h2 id="_5-1-相关操作"><a href="#_5-1-相关操作" class="header-anchor">#</a> 5.1 相关操作</h2> <p>（1）查看/设置事务提交方式</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>#查看当前数据库事务提交方式（1为自动提交，0为手动提交）
SELECT @@autocommit;
#设置事务提交方式
SET @@autocommit = 0;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>（2）开启事务</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>START TRANSACTION 或 BEGIN ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>（3） 提交事务</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>COMMIT; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>（4）回滚事务</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>ROLLBACK; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_5-2-四大特性acid"><a href="#_5-2-四大特性acid" class="header-anchor">#</a> 5.2 四大特性ACID</h2> <ul><li>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li> <li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li> <li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li> <li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul> <blockquote><p>InnoDB引擎通过什么技术来保证事务的这四个特性的呢？</p></blockquote> <ul><li>持久性是通过 redo log （重做日志）来保证的；</li> <li>原子性是通过 undo log（回滚日志） 来保证的；</li> <li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li> <li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul> <h2 id="_5-2-并发事务可能引发的问题"><a href="#_5-2-并发事务可能引发的问题" class="header-anchor">#</a> 5.2 并发事务可能引发的问题</h2> <p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p> <p>那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p> <table><thead><tr><th>问题</th> <th>描述</th></tr></thead> <tbody><tr><td>脏读</td> <td>一个事务读到另一个事务还没提交的数据</td></tr> <tr><td>不可重复读</td> <td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr> <tr><td>幻读</td> <td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在（前后读取的记录数量不一致。）</td></tr></tbody></table> <h2 id="_5-3事务的隔离级别"><a href="#_5-3事务的隔离级别" class="header-anchor">#</a> 5.3事务的隔离级别</h2> <p>多个事务并发执行时可能会遇到上述问题，因此SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p> <ul><li><strong>读未提交（read uncommitted）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li> <li><strong>读提交（read committed）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li> <li><strong>可重复读（repeatable read）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li> <li><strong>串行化（serializable ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul> <table><thead><tr><th>隔离级别</th> <th>脏读</th> <th>不可重复读</th> <th>幻读</th></tr></thead> <tbody><tr><td>Read uncommitted</td> <td>√</td> <td>√</td> <td>√</td></tr> <tr><td>Read committed</td> <td>×</td> <td>√</td> <td>√</td></tr> <tr><td>Repeatable Read(innodb默认隔离级别)</td> <td>×</td> <td>×</td> <td>√</td></tr> <tr><td>Serializable</td> <td>×</td> <td>×</td> <td>×</td></tr></tbody></table> <blockquote><p>InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它通过next-key lock 锁（行锁和间隙锁的组合）来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。</p></blockquote> <ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li> <li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li> <li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View *<em>来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。*</em>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</li></ul> <p>查看事务隔离级别：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT @@TRANSACTION_ISOLATION;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>设置事务隔离级别：
<code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };</code>
SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p> <h1 id="六、存储引擎"><a href="#六、存储引擎" class="header-anchor">#</a> 六、存储引擎</h1> <h2 id="_6-1-mysql体系结构"><a href="#_6-1-mysql体系结构" class="header-anchor">#</a> 6.1 MySQL体系结构</h2> <img src="https://dhc.pythonanywhere.com/media/editor/MySQL体系结构_20220315034329549927.png" alt="结构图" title="结构图" style="zoom:67%;">
**(1)连接层**
最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于
TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程
池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务
器也会为安全接入的每个客户端验证它所具有的操作权限。
**(2) 服务层**
第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部
分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解
析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，
最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，
这样在解决大量读操作的环境中能够很好的提升系统的性能。
**(3) 引擎层**
存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通
信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库
中的索引是在存储引擎层实现的。
**(4)存储层**
数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询
日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。
<blockquote><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要
体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。
这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p></blockquote> <h2 id="_6-2-存储引擎"><a href="#_6-2-存储引擎" class="header-anchor">#</a> 6.2 存储引擎</h2> <blockquote><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。mysql 默认存储引擎是InnoDB。</p></blockquote> <p>相关操作：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 查询建表语句
show create table account;
-- 建表时指定存储引擎
CREATE TABLE 表名(
	...
) ENGINE=INNODB;
-- 查看当前数据库支持的存储引擎
show engines;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_6-3-存储引擎特点"><a href="#_6-3-存储引擎特点" class="header-anchor">#</a> 6.3 存储引擎特点</h2> <h3 id="innodb"><a href="#innodb" class="header-anchor">#</a> InnoDB</h3> <p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p> <p><strong>(1)特点：</strong></p> <ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li> <li><strong>行级锁</strong>，提高并发访问性能</li> <li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul> <p><strong>(2)文件：</strong></p> <ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul> <p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>show variables like 'innodb_file_per_table';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220420203945315.png" alt="image-20220420203945315"></p> <p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。</p> <p><img src="http://img.aismy.top/img/image-20220420204150038.png" alt="image-20220420204150038"></p> <blockquote><p>可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表show variables like 'innodb_file_per_table'; 1的表结构。</p></blockquote> <p>从idb文件提取表结构数据：<code>ibd2sdi xxx.ibd</code></p> <p><img src="http://img.aismy.top/img/image-20220420204348126.png" alt="image-20220420204348126"></p> <p><strong>(3)逻辑存储结构:</strong> <img src="https://dhc.pythonanywhere.com/media/editor/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p> <ul><li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以
包含多个Segment段。</li> <li>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管
理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</li> <li>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为
16K， 即一个区中一共有64个连续的页。</li> <li>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默
认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li> <li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时
所指定的字段以外，还包含两个隐藏字段</li></ul> <h3 id="myisam"><a href="#myisam" class="header-anchor">#</a> MyISAM</h3> <p>MyISAM 是 MySQL 早期的默认存储引擎。</p> <p>特点：</p> <ul><li>不支持事务，不支持外键</li> <li>支持表锁，不支持行锁</li> <li>访问速度快</li></ul> <p>文件：</p> <ul><li>xxx.sdi: 存储表结构信息</li> <li>xxx.MYD: 存储数据</li> <li>xxx.MYI: 存储索引</li></ul> <h3 id="memory"><a href="#memory" class="header-anchor">#</a> Memory</h3> <p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p> <p>特点：</p> <ul><li>存放在内存中，速度快</li> <li>hash索引（默认）</li></ul> <p>文件：</p> <ul><li>xxx.sdi: 存储表结构信息</li></ul> <h3 id="存储引擎特点"><a href="#存储引擎特点" class="header-anchor">#</a> 存储引擎特点</h3> <table><thead><tr><th>特点</th> <th>InnoDB</th> <th>MyISAM</th> <th>Memory</th></tr></thead> <tbody><tr><td>存储限制</td> <td>64TB</td> <td>有</td> <td>有</td></tr> <tr><td>事务安全</td> <td>支持</td> <td>-</td> <td>-</td></tr> <tr><td>锁机制</td> <td>行锁</td> <td>表锁</td> <td>表锁</td></tr> <tr><td>B+tree索引</td> <td>支持</td> <td>支持</td> <td>支持</td></tr> <tr><td>Hash索引</td> <td>-</td> <td>-</td> <td>支持</td></tr> <tr><td>全文索引</td> <td>支持（5.6版本之后）</td> <td>支持</td> <td>-</td></tr> <tr><td>空间使用</td> <td>高</td> <td>低</td> <td>N/A</td></tr> <tr><td>内存使用</td> <td>高</td> <td>低</td> <td>中等</td></tr> <tr><td>批量插入速度</td> <td>低</td> <td>高</td> <td>高</td></tr> <tr><td>支持外键</td> <td>支持</td> <td>-</td> <td>-</td></tr></tbody></table> <h2 id="_6-4-存储引擎的选择"><a href="#_6-4-存储引擎的选择" class="header-anchor">#</a> 6.4 存储引擎的选择</h2> <p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p> <ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li> <li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li> <li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul> <p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p> <h1 id="七、索引"><a href="#七、索引" class="header-anchor">#</a> 七、索引</h1> <blockquote><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p></blockquote> <blockquote><p>InnoDB 的数据是按<code>「数据页」</code>为单位来读写的，默认数据页大小为 16 KB。<strong>每个数据页之间通过双向链表的形式组织起来</strong>，物理上不连续，但是逻辑上连续。</p> <p>数据页内包含用户记录，<strong>每个记录之间用单向链表的方式组织起来</strong>，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</p> <p>为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。</p> <p>如果叶子节点存储的是实际数据的就是聚簇【，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</p> <p>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。</p></blockquote> <p><strong>优点：</strong></p> <ul><li>提高数据检索效率，降低数据库的IO成本</li> <li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul> <p><strong>缺点：</strong></p> <ul><li>索引列也是要占用空间的</li> <li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul> <h2 id="_7-1索引结构"><a href="#_7-1索引结构" class="header-anchor">#</a> 7.1索引结构</h2> <p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p> <table><thead><tr><th>索引结构</th> <th>描述</th></tr></thead> <tbody><tr><td>B+Tree</td> <td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr> <tr><td>Hash</td> <td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr> <tr><td>R-Tree(空间索引)</td> <td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr> <tr><td>Full-Text(全文索引)</td> <td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table> <table><thead><tr><th>索引</th> <th>InnoDB</th> <th>MyISAM</th> <th>Memory</th></tr></thead> <tbody><tr><td>B+Tree索引</td> <td>支持</td> <td>支持</td> <td>支持</td></tr> <tr><td>Hash索引</td> <td>不支持</td> <td>不支持</td> <td>支持</td></tr> <tr><td>R-Tree索引</td> <td>不支持</td> <td>支持</td> <td>不支持</td></tr> <tr><td>Full-text</td> <td>5.6版本后支持</td> <td>支持</td> <td>不支持</td></tr></tbody></table> <h3 id="_7-1-1-二叉树"><a href="#_7-1-1-二叉树" class="header-anchor">#</a> 7.1.1 二叉树</h3> <p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p> <img src="http://img.aismy.top/img/image-20220420205516599.png" alt="image-20220420205516599" style="zoom:50%;"> <p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p> <img src="http://img.aismy.top/img/image-20220420205535779.png" alt="image-20220420205535779" style="zoom:50%;"> <p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p> <ul><li>顺序插入时，会形成一个链表，查询性能大大降低。</li> <li>大数据量情况下，层级较深，检索速度慢。</li></ul> <p>此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数
据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:</p> <img src="http://img.aismy.top/img/image-20220420205636785.png" alt="image-20220420205636785" style="zoom:50%;"> <p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p> <ul><li>大数据量情况下，层级较深，检索速度慢。</li></ul> <blockquote><p>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree，那么什么是
B+Tree呢？在详解B+Tree之前，先来介绍一个B-Tree。</p></blockquote> <h3 id="_7-1-2-b-tree"><a href="#_7-1-2-b-tree" class="header-anchor">#</a> 7.1.2 B-Tree</h3> <blockquote><p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：</p></blockquote> <p><img src="http://img.aismy.top/img/image-20220420205849150.png" alt="image-20220420205849150"></p> <p>特点：</p> <ul><li>5阶的B树，每一个节点最多存储4个key，对应5个指针。</li> <li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</li> <li>在B树中，非叶子节点和叶子节点都会存放数据。</li></ul> <h3 id="_7-1-3-b-tree"><a href="#_7-1-3-b-tree" class="header-anchor">#</a> 7.1.3 B+Tree</h3> <p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：</p> <p><img src="https://dhc.pythonanywhere.com/media/editor/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p> <p>我们可以看到，两部分：</p> <ul><li>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</li> <li>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据</li></ul> <p>与 B-Tree 的区别：</p> <ul><li>所有的数据都会出现在叶子节点</li> <li>叶子节点形成一个单向链表</li> <li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li></ul> <p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p> <p><img src="http://img.aismy.top/img/image-20220420210308555.png" alt="image-20220420210308555"></p> <h3 id="_7-1-4-hash"><a href="#_7-1-4-hash" class="header-anchor">#</a> 7.1.4 Hash</h3> <p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。
如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p> <p><img src="http://img.aismy.top/img/image-20220420210404374.png" alt="image-20220420210404374"></p> <p>特点：</p> <ul><li>Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、...）</li> <li>无法利用索引完成排序操作</li> <li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul> <p>存储引擎支持：</p> <ul><li>Memory</li> <li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul> <h4 id="面试题"><a href="#面试题" class="header-anchor">#</a> 面试题</h4> <ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol> <ul><li>相对于二叉树，层级更少，搜索效率高</li> <li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li> <li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul> <h2 id="_7-2-索引分类"><a href="#_7-2-索引分类" class="header-anchor">#</a> 7.2 索引分类</h2> <table><thead><tr><th>分类</th> <th>含义</th> <th>特点</th> <th>关键字</th></tr></thead> <tbody><tr><td>主键索引</td> <td>针对于表中主键创建的索引</td> <td>默认自动创建，只能有一个</td> <td>PRIMARY</td></tr> <tr><td>唯一索引</td> <td>避免同一个表中某数据列中的值重复</td> <td>可以有多个。</td> <td>UNIQUE</td></tr> <tr><td>常规索引</td> <td>快速定位特定数据</td> <td>可以有多个</td> <td></td></tr> <tr><td>全文索引</td> <td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td> <td>可以有多个</td> <td>FULLTEXT</td></tr></tbody></table> <blockquote><p>创建唯一约束时，会自动的创建唯一索引，也可为没有设置唯一约束的字段设置唯一索引</p></blockquote> <p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p> <table><thead><tr><th>分类</th> <th>含义</th> <th>特点</th></tr></thead> <tbody><tr><td>聚集索引(Clustered Index)</td> <td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td> <td>必须有，而且只有一个</td></tr> <tr><td>二级索引(Secondary Index)</td> <td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td> <td>可以存在多个</td></tr></tbody></table> <p>聚集索引选取规则:</p> <ul><li>如果存在主键，主键索引就是聚集索引。</li> <li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li> <li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li></ul> <p>聚集索引和二级索引的具体结构如下：</p> <p><img src="http://img.aismy.top/img/image-20220420211226994.png" alt="image-20220420211226994"></p> <ul><li>聚集索引的叶子节点下挂的是这一行的数据 。</li> <li>二级索引的叶子节点下挂的是该字段值对应的主键值</li></ul> <h4 id="思考题"><a href="#思考题" class="header-anchor">#</a> 思考题</h4> <p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>select * from user where id = 10;
select * from user where name = 'Arm';
-- 备注：id为主键，name字段创建的有索引
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p> <p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p> <p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.
可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p> <p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；
如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p> <p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p> <h2 id="_7-3-索引语法"><a href="#_7-3-索引语法" class="header-anchor">#</a> 7.3 索引语法</h2> <p>(1)创建索引：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (
index_col_name,... ) ;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p> <p>验证：创建唯一约束时，会自动的创建唯一索引</p> <p><img src="upload%5Cimage-20220420214946907.png" alt="image-20220420214946907"></p> <p>(2)查看索引：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SHOW INDEX FROM table_name;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(3)删除索引：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>DROP INDEX index_name ON table_name;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>案例：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引
create index idx_user_name on tb_user(name);
-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引
create unique index idx_user_phone on tb_user (phone);
-- 为profession, age, status创建联合索引
create index idx_user_pro_age_stat on tb_user(profession, age, status);
-- 为email建立合适的索引来提升查询效率
create index idx_user_email on tb_user(email);

-- 删除索引
drop index idx_user_email on tb_user;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_7-4-sql性能分析"><a href="#_7-4-sql性能分析" class="header-anchor">#</a> 7.4 SQL性能分析</h2> <h3 id="_7-4-1-sql执行频率"><a href="#_7-4-1-sql执行频率" class="header-anchor">#</a> 7.4.1  SQL执行频率</h3> <p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- session 是查看当前会话 ;
-- global 是查询全局数据 ;
SHOW GLOBAL STATUS LIKE 'Com_______';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><img src="http://img.aismy.top/img/image-20220420215611526.png" alt="image-20220420215611526" style="zoom:67%;"> <blockquote><p>通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据
库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以
查询为主，那么就要考虑对数据库的索引进行优化了。</p></blockquote> <p>那假如说是以查询为主，我们又该如何定位针对于那些查询语句进行优化呢？我们可以借助于慢查询日志。</p> <h3 id="_7-4-2-慢查询日志"><a href="#_7-4-2-慢查询日志" class="header-anchor">#</a> 7.4.2 慢查询日志</h3> <p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。
MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p> <p><img src="http://img.aismy.top/img/image-20220420220143736.png" alt="image-20220420220143736"></p> <p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code># 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息</p> <p>/var/lib/mysql/localhost-slow.log</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>systemctl restart mysqld 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>然后，再次查看开关情况，慢查询日志就已经打开了。</p> <p><img src="http://img.aismy.top/img/image-20220420220312698.png" alt="image-20220420220312698"></p> <p>测试：</p> <p>执行如下SQL语句 ：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>select * from tb_user; -- 这条SQL执行效率比较高, 执行耗时 0.00sec
select count(*) from tb_sku; -- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时
13.35sec
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220420220559636.png" alt="image-20220420220559636"></p> <p>检查慢查询日志 ：</p> <p>最终我们发现，在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的SQL，执行较快的SQL
是不会记录的。</p> <p><img src="http://img.aismy.top/img/image-20220420220616386.png" alt="image-20220420220616386"></p> <p>那这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化。</p> <h3 id="_7-4-3-profile详情"><a href="#_7-4-3-profile详情" class="header-anchor">#</a> 7.4.3 profile详情</h3> <p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SELECT @@have_profiling ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220420220910979.png" alt="image-20220420220910979"></p> <p>可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在session/global级别开启profiling：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>SET profiling = 1; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>开关已经打开了，接下来，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去了。 我们直接执行如下的SQL语句：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>select * from tb_user;
select * from tb_user where id = 1;
select * from tb_user where name = '白起';
select count(*) from tb_sku;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 查看每一条SQL的耗时基本情况
show profiles;
-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;
-- 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>查看每一条SQL的耗时情况:</p> <p><img src="http://img.aismy.top/img/image-20220420221716561.png" alt="image-20220420221716561"></p> <p>查看指定SQL各个阶段的耗时情况 :</p> <p><img src="http://img.aismy.top/img/image-20220420221727616.png" alt="image-20220420221727616"></p> <h3 id="_7-4-4-explain"><a href="#_7-4-4-explain" class="header-anchor">#</a> 7.4.4  explain</h3> <p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220420221937223.png" alt="image-20220420221937223"></p> <p>Explain 执行计划中各个字段的含义:</p> <table><thead><tr><th>字段</th> <th>含义</th></tr></thead> <tbody><tr><td>id</td> <td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td></tr> <tr><td>select_type</td> <td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等</td></tr> <tr><td>type</td> <td>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。</td></tr> <tr><td>possible_key</td> <td>显示可能应用在这张表上的索引，一个或多个。</td></tr> <tr><td>key</td> <td>实际使用的索引，如果为NULL，则没有使用索引。</td></tr> <tr><td>key_len</td> <td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</td></tr> <tr><td>rows</td> <td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</td></tr> <tr><td>filtered</td> <td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好</td></tr></tbody></table> <h2 id="_7-5-索引使用规则"><a href="#_7-5-索引使用规则" class="header-anchor">#</a> 7.5 索引使用规则</h2> <h3 id="_7-5-1最左前缀法则"><a href="#_7-5-1最左前缀法则" class="header-anchor">#</a> 7.5.1最左前缀法则</h3> <p>如果索引关联了多列（联合索引），要遵守最左前缀法则</p> <p>对于最左前缀法则指的是，查询时，最左变的列，<code>必须存在</code>，否则索引全部失效。
而且中间不能跳过某一列，否则该列后面的字段索引将失效。</p> <blockquote><p>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p></blockquote> <h3 id="_7-5-2-范围查询"><a href="#_7-5-2-范围查询" class="header-anchor">#</a> 7.5.2 范围查询</h3> <p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>explain select * from tb_user where profession = '软件工程' and age &gt; 30 and status= '0';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>范围查询右边的status字段索引失效</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>explain select * from tb_user where profession = '软件工程' and age &gt;= 30 and status = '0';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当范围查询使用&gt;= 或 &lt;= 时，走联合索引了</p> <blockquote><p>所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt;</p></blockquote> <h2 id="_7-6-索引失效情况"><a href="#_7-6-索引失效情况" class="header-anchor">#</a> 7.6 索引失效情况</h2> <h3 id="_7-6-1-索引列运算"><a href="#_7-6-1-索引列运算" class="header-anchor">#</a> 7.6.1 索引列运算</h3> <p>在索引列上进行运算操作，索引将失效。</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>explain select * from tb_user where substring(phone, 10, 2) = '15';
#phone列上有索引，但因为对其进行了运算操作，索引失效
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421091624779.png" alt="image-20220421091624779"></p> <h3 id="_7-6-2-字符串不加引号"><a href="#_7-6-2-字符串不加引号" class="header-anchor">#</a> 7.6.2 字符串不加引号</h3> <p>字符串类型字段使用时，不加引号，索引将失效。</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>explain select * from tb_user where phone = 17799990015;
#此处phone的值没有加引号，索引失效
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421091812832.png" alt="image-20220421091812832"></p> <blockquote><p>字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。</p></blockquote> <h3 id="_7-6-3-模糊查询"><a href="#_7-6-3-模糊查询" class="header-anchor">#</a> 7.6.3 模糊查询</h3> <p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。
由于下面查询语句中，都是根据profession字段查询，符合最左前缀法则，联合索引是可以生效的，
我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。</p> <p>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>explain select * from tb_user where phone like '%14';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421092028724.png" alt="image-20220421092028724"></p> <p><strong>前后都有 % 也会失效</strong></p> <p><img src="http://img.aismy.top/img/image-20220421092111692.png" alt="image-20220421092111692"></p> <h3 id="_7-6-3-or连接条件"><a href="#_7-6-3-or连接条件" class="header-anchor">#</a> 7.6.3 or连接条件</h3> <p>用 or 分割开的条件，如果or其中一个条件的列没有索引，那么涉及的索引都不会被用到。</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>explain select * from tb_user where phone like '14%' or age=22;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421093421756.png" alt="image-20220421093421756"></p> <p>如上图所示，可能用到索引phone，但最终没有用到索引。phone有索引，但是age字段没有索引，因此phone索引也会失效。</p> <p>给age字段添加索引：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>create index age on tb_user(age);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421093524890.png" alt="image-20220421093524890"></p> <p>然后再次执行刚才的查询语句：</p> <p><img src="http://img.aismy.top/img/image-20220421093559488.png" alt="image-20220421093559488"></p> <p>可见，age字段添加索引后，改查询语句使用了两个索引。由此验证了:</p> <blockquote><p>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</p></blockquote> <h3 id="_7-6-4-数据分布影响"><a href="#_7-6-4-数据分布影响" class="header-anchor">#</a> 7.6.4 数据分布影响</h3> <p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p> <p><img src="http://img.aismy.top/img/image-20220421094100956.png" alt="image-20220421094100956"></p> <p>测试的数据库中age字段最小为10</p> <p>经过测试我们发现，相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为
什么呢？
就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。因此当age范围越来越大，返回的数据越来越多，当到达一定阙值时，索引失效。</p> <blockquote><p>结论：当索引查询返回大批量数据时，此时数据库评估使用索引的效率比全表扫描慢，索引失效。</p></blockquote> <blockquote><p>is null 、is not null是否走索引，得具体情况具体分析（数据库中数据分布），并不是固定的。</p></blockquote> <h2 id="_7-7-sql-提示-指定要使用的索引"><a href="#_7-7-sql-提示-指定要使用的索引" class="header-anchor">#</a> 7.7 SQL 提示(指定要使用的索引)</h2> <p>先来看一下数据库索引情况：</p> <p>name字段，有一个单列索引，还有一个name和phone的联合索引</p> <p><img src="http://img.aismy.top/img/image-20220421095025358.png" alt="image-20220421095025358"></p> <p>那么再进行关于name字段的查询语句时，会使用那个索引呢？</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code> explain select * from tb_user where name='蔡强';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421095404077.png" alt="image-20220421095404077"></p> <p>分析上图：可能使用的索引：name和name_phone,但最终使用了name单列索引这是MySQL自动选择的结果。
那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于
MySQL的SQL提示来完成。</p> <blockquote><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优
化操作的目的。</p></blockquote> <p>(1) <code>use index</code>： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>explain select * from tb_user use index(name_phone) where name='蔡强';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421095847963.png" alt="image-20220421095847963"></p> <p>测试可见，此次使用的索引为我们所指定的索引</p> <p>(2) <code>ignore index</code>： 忽略指定的索引。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>explain select * from tb_user  ignore index(name_phone) where name='蔡强';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421100321775.png" alt="image-20220421100321775"></p> <p>测试可见，此次不在使用name_phone，而是使用另一个name索引</p> <p>(3)	<code>force index</code> ： 强制使用索引。</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>explain select * from tb_user force  index(name_phone) where name='蔡强';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421100534842.png" alt="image-20220421100534842"></p> <blockquote><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p></blockquote> <h2 id="_7-8-覆盖索引-回表查询"><a href="#_7-8-覆盖索引-回表查询" class="header-anchor">#</a> 7.8 覆盖索引&amp;回表查询</h2> <p>尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？</p> <blockquote><p>覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</p></blockquote> <p>下面进行测试，执行几个查询语句</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>explain select id, profession from tb_user where profession = '软件工程' and age =
31 and status = '0' ;
explain select id,profession,age, status from tb_user where profession = '软件工程'
and age = 31 and status = '0' ;
explain select id,profession,age, status, name from tb_user where profession = '软
件工程' and age = 31 and status = '0' ;
explain select * from tb_user where profession = '软件工程' and age = 31 and status
= '0';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421110803133.png" alt="image-20220421110803133"></p> <p>从上述的执行计划我们可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的Extra，前面两天SQL的结果为 Using where; UsingIndex ; 而后面两条SQL的结果为: Using index condition 。</p> <p><img src="http://img.aismy.top/img/image-20220421110827663.png" alt="image-20220421110827663"></p> <p>因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是<code>回表</code>。 而我们如果一直使用<code>select *</code>查询返回所有字段值，很容易就会造成回表</p> <p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p> <blockquote><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：
<code>select id, username, password from tb_user where username='itcast';</code></p> <p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p></blockquote> <h2 id="_7-9-前缀索引"><a href="#_7-9-前缀索引" class="header-anchor">#</a> 7.9 前缀索引</h2> <blockquote><p>当字段类型为字符串（<code>varchar，text，longtext</code>等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p></blockquote> <p><strong>语法：</strong></p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>create index idx_xxxx on table_name(columnn(n));
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>示例:</strong></p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>#为tb_user表的email字段，建立长度为5的前缀索引。
create index email on tb_user(email(5));
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421111405236.png" alt="image-20220421111405236"></p> <p>**前缀长度：**可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。
求选择性公式：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>select count(distinct email) / count(*) from tb_user;
select count(distinct substring(email, 1, 5)) / count(*) from tb_user;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421111606714.png" alt="image-20220421111606714"></p> <p>show index 里面的sub_part可以看到接取的长度</p> <h2 id="_7-10-单列索引-联合索引"><a href="#_7-10-单列索引-联合索引" class="header-anchor">#</a> 7.10 单列索引&amp;联合索引</h2> <ul><li>单列索引：即一个索引只包含单个列</li> <li>联合索引：即一个索引包含了多个列</li></ul> <p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p> <blockquote><p>注意事项</p> <ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul></blockquote> <h2 id="_7-11-设计原则"><a href="#_7-11-设计原则" class="header-anchor">#</a> 7.11 设计原则</h2> <ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li> <li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li> <li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li> <li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li> <li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li> <li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li> <li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol> <h1 id="八、sql-优化"><a href="#八、sql-优化" class="header-anchor">#</a> 八、SQL 优化</h1> <h2 id="_8-1-插入数据"><a href="#_8-1-插入数据" class="header-anchor">#</a> 8.1 插入数据</h2> <ol><li>采用批量插入（一次插入的数据不建议超过1000条）</li></ol> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>Insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry'); 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="2"><li>手动提交事务</li></ol> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>start transaction;
insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');
commit;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="3"><li>主键顺序插入</li></ol> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3
主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89
#主键顺序插入，性能要高于乱序插入。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="4"><li>大批量插入使用load指令：</li></ol> <p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p> <p><img src="http://img.aismy.top/img/image-20220421113145727.png" alt="image-20220421113145727"></p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）
mysql --local-infile -u root -p
# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;
select @@local_infile;
# 执行load指令将准备好的数据，加载到表结构中
load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\n';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_8-2-主键优化"><a href="#_8-2-主键优化" class="header-anchor">#</a> 8.2 主键优化</h2> <p>主键顺序插入的性能是要高于乱序插入的，那么主键又该如何设计？</p> <h3 id="_8-2-1-数据组织方式"><a href="#_8-2-1-数据组织方式" class="header-anchor">#</a> 8.2.1 数据组织方式</h3> <p>在InnoDB存储引擎中，<strong>表数据都是根据主键顺序组织存放的</strong>，这种存储方式的表称为索引组织表（Index organized table, IOT）</p> <p><img src="http://img.aismy.top/img/image-20220421113718186.png" alt="image-20220421113718186"></p> <p>行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过InnoDB的逻辑结构图：</p> <p><img src="http://img.aismy.top/img/image-20220421113733663.png" alt="image-20220421113733663"></p> <p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。
那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不下，将会存储
到下一个页中，页与页之间会通过指针连接。</p> <h3 id="_8-2-2-页分裂"><a href="#_8-2-2-页分裂" class="header-anchor">#</a> 8.2.2 页分裂：</h3> <p>页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。</p> <p>A. 主键顺序插入效果</p> <p>①. 从磁盘中申请页， 主键顺序插入</p> <p><img src="http://img.aismy.top/img/image-20220421113954533.png" alt="image-20220421113954533"></p> <p>②. 第一个页没有满，继续往第一页插入</p> <p><img src="http://img.aismy.top/img/image-20220421114008034.png" alt="image-20220421114008034"></p> <p>③. 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p> <p><img src="http://img.aismy.top/img/image-20220421114023099.png" alt="image-20220421114023099"></p> <p>④. 当第二页写满了，再往第三页写入</p> <p><img src="http://img.aismy.top/img/image-20220421114046733.png" alt="image-20220421114046733"></p> <p>B. 主键乱序插入效果</p> <p>①. 加入1#,2#页都已经写满了，存放了如图所示的数据</p> <p><img src="http://img.aismy.top/img/image-20220421114116492.png" alt="image-20220421114116492"></p> <p>②. 此时再插入id为50的记录，我们来看看会发生什么现象</p> <p>会再次开启一个页，写入新的页中吗？</p> <p><img src="http://img.aismy.top/img/image-20220421114145014.png" alt="image-20220421114145014"></p> <p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p> <p><img src="http://img.aismy.top/img/image-20220421114215912.png" alt="image-20220421114215912"></p> <p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p> <p><img src="http://img.aismy.top/img/image-20220421114238413.png" alt="image-20220421114238413"></p> <p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p> <p><img src="http://img.aismy.top/img/image-20220421114250124.png" alt="image-20220421114250124"></p> <p><img src="http://img.aismy.top/img/image-20220421114315722.png" alt="image-20220421114315722"></p> <p>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个
页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。</p> <p><img src="http://img.aismy.top/img/image-20220421114333399.png" alt="image-20220421114333399"></p> <p>上述的这种现象，称之为 &quot;页分裂&quot;，是比较耗费性能的操作。</p> <h3 id="_8-2-3-页合并"><a href="#_8-2-3-页合并" class="header-anchor">#</a> 8.2.3 页合并：</h3> <p>目前表中已有数据的索引结构(叶子节点)如下：</p> <p><img src="http://img.aismy.top/img/image-20220421114459974.png" alt="image-20220421114459974"></p> <p>当我们对已有数据进行删除时，具体的效果如下:
当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间
变得允许被其他记录声明使用。</p> <p><img src="http://img.aismy.top/img/image-20220421114521699.png" alt="image-20220421114521699"></p> <p>当我们继续删除2#的数据记录</p> <p><img src="http://img.aismy.top/img/image-20220421114747956.png" alt="image-20220421114747956"></p> <p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前
或后）看看是否可以将两个页合并以优化空间使用。</p> <p><img src="http://img.aismy.top/img/image-20220421114807364.png" alt="image-20220421114807364"></p> <p><img src="http://img.aismy.top/img/image-20220421114814838.png" alt="image-20220421114814838"></p> <p>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页</p> <p><img src="http://img.aismy.top/img/image-20220421114827438.png" alt="image-20220421114827438"></p> <p>这个里面所发生的合并页的这个现象，就称之为 &quot;页合并&quot;。</p> <blockquote><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p></blockquote> <h3 id="_8-2-4-主键设计原则"><a href="#_8-2-4-主键设计原则" class="header-anchor">#</a> 8.2.4 主键设计原则：</h3> <ul><li>满足业务需求的情况下，尽量降低主键的长度(长度越小一页中可存入的索引越多)</li> <li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li> <li>尽量不要使用 UUID 做主键或者是其他的自然主键(不连续，容易造成页分裂)，如身份证号</li> <li>业务操作时，避免对主键的修改</li></ul> <h2 id="_8-3-order-by优化"><a href="#_8-3-order-by优化" class="header-anchor">#</a> 8.3 order by优化</h2> <blockquote><p>MySQL的排序，有两种方式：</p></blockquote> <ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li> <li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol> <p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。</p> <p>如果order by字段全部使用升序排序或者降序排序，则都会走索引</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>EXPLAIN SELECT name FROM `tb_user` ORDER BY `name` ASC ,id ASC
EXPLAIN SELECT name FROM `tb_user` ORDER BY `name` DESC ,id DESC
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="http://img.aismy.top/img/image-20220421120241410.png" alt="image-20220421120241410"></p> <p>全部使用升序排序或者降序排序，则都会走索引，因为建立索引时mysql默认为asc，</p> <p>但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p> <p>总结：</p> <ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li> <li>尽量使用覆盖索引</li> <li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li> <li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul> <h2 id="_8-4-group-by优化"><a href="#_8-4-group-by优化" class="header-anchor">#</a> 8.4 group by优化</h2> <ul><li>在分组操作时，可以通过索引来提高效率</li> <li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul> <p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession... order by age</code>，这样也符合最左前缀法则</p> <h2 id="_8-5-limit优化"><a href="#_8-5-limit优化" class="header-anchor">#</a> 8. 5 limit优化</h2> <p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p> <p>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记
录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p> <p>优化思路: 一般分页查询时，通过创建<code>覆盖索引</code>能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p> <p>例如：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>-- 此语句耗时很长
select * from tb_sku limit 9000000, 10;
-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询
select id from tb_sku order by id limit 9000000, 10;
-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit
-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);
-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度
explain select * 
from tb_sku t , (select id from tb_sku order by idlimit 2000000,10) a 
where t.id = a.id;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_8-6-count优化"><a href="#_8-6-count优化" class="header-anchor">#</a> 8.6 count优化</h2> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>select count(*) from tb_user ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p> <ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；</li> <li>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。</li></ul> <p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：</p> <p><strong>第一种，近似值</strong></p> <p>可以使用 show table status 或者 explain 命令来表进行估算。</p> <p>执行 explain 命令效率是很高的，因为它并不会真正的去查询， rows 字段值就是 explain 命令对表记录的估算值。</p> <p><em><strong>第二种，额外表保存计数值</strong></em></p> <p>如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。（或者用redis缓存）</p> <p>当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。</p> <p><strong>count的几种用法：</strong></p> <p><img src="http://img.aismy.top/img/image-20220421121838969.png" alt="image-20220421121838969"></p> <p><strong>count(<code>\*</code>) 其实等于 count(<code>0</code>)</strong>，也就是说，当你使用 count(<code>*</code>) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理。</p> <p>所以，<strong>count(*) 执行过程跟 count(1) 执行过程基本一样的</strong>，性能没有什么差异。</p> <p>而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。只有当没有二级索引的时候，才会采用主键索引来进行统计。</p> <p>按效率排序：<img src="http://img.aismy.top/img/af711033aa3423330d3a4bc6baeb9532.png" alt="图片"></p> <blockquote><p>小结：</p> <p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p> <p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。</p> <p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p></blockquote> <h2 id="_8-7-update优化-避免行锁升级为表锁"><a href="#_8-7-update优化-避免行锁升级为表锁" class="header-anchor">#</a> 8.7 update优化（避免行锁升级为表锁）</h2> <p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p> <p>如以下两条语句：
<code>update student set no = '123' where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；
<code>update student set no = '123' where name = 'test';</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p> <blockquote><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</p></blockquote> <h1 id="九、锁"><a href="#九、锁" class="header-anchor">#</a> 九、锁</h1> <h2 id="_9-1-、概述"><a href="#_9-1-、概述" class="header-anchor">#</a> 9.1 、概述</h2> <blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p></blockquote> <p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p> <ul><li>全局锁：锁定数据库中的所有表。</li> <li>表级锁：每次操作锁住整张表。</li> <li>行级锁：每次操作锁住对应的行数据。</li></ul> <h2 id="_9-2-全局锁"><a href="#_9-2-全局锁" class="header-anchor">#</a> 9.2 全局锁</h2> <p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语
句，已经更新操作的事务提交语句都将被阻塞。</p> <h3 id="语法"><a href="#语法" class="header-anchor">#</a> 语法</h3> <p>(1)加全局锁</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>flush tables with read lock ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>(2)释放锁</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>unlock tables ; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h3> <p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整
性。</p> <p><img src="http://img.aismy.top/img/image-20220421133940071.png" alt="image-20220421133940071"></p> <p>对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、
DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。
那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性
和完整性。</p> <p>数据备份:</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>mysqldump -uroot –p123456 itcast &gt; itcast.sql 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h3> <p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p> <ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li> <li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导
致主从延迟。</li></ul> <blockquote><p>既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p></blockquote> <p>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p> <p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p> <p>备份数据库的工具是mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p> <p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p> <p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p> <h2 id="_9-3表级锁"><a href="#_9-3表级锁" class="header-anchor">#</a> 9.3表级锁</h2> <blockquote><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p></blockquote> <p>对于表级锁，主要分为以下三类：</p> <ul><li>表锁</li> <li>元数据锁（meta data lock，MDL）</li> <li>意向锁</li></ul> <h3 id="_9-3-1-表锁"><a href="#_9-3-1-表锁" class="header-anchor">#</a> 9.3.1 表锁</h3> <p>对于表锁，分为两类：</p> <ul><li>表共享读锁（read lock）也就是读锁</li> <li>表独占写锁（write lock）也就是写锁</li></ul> <h4 id="语法-2"><a href="#语法-2" class="header-anchor">#</a> 语法</h4> <ul><li>加锁：lock tables 表名... read/write。</li> <li>释放锁：unlock tables / 客户端断开连接 。</li></ul> <h4 id="写锁"><a href="#写锁" class="header-anchor">#</a> <strong>写锁</strong></h4> <p><img src="http://img.aismy.top/img/image-20220421142336680.png" alt="image-20220421142336680"></p> <p><img src="http://img.aismy.top/img/image-20220421141912402.png" alt="image-20220421141912402"></p> <p>在第一个客户端中加锁,此时改客户端与其他客户端均可进行DQL操作</p> <p>但是都不能进行写操作,本客户端直接进行报错提示,而其他客户端会被阻塞,一直到锁被释放</p> <h4 id="读锁"><a href="#读锁" class="header-anchor">#</a> 读锁</h4> <p><img src="http://img.aismy.top/img/image-20220421142443323.png" alt="image-20220421142443323"></p> <p><img src="http://img.aismy.top/img/image-20220421145324043.png" alt="image-20220421145324043"></p> <h3 id="_9-3-2-元数据锁"><a href="#_9-3-2-元数据锁" class="header-anchor">#</a> 9.3.2 元数据锁</h3> <p>meta data lock , 元数据锁，简写MDL。</p> <blockquote><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。</p> <p>MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p></blockquote> <p>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务
时，是不能够修改这张表的表结构的。</p> <p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p> <ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li> <li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul> <p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p> <p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p> <p>可以通过下面的SQL，来查看数据库中的元数据锁的情况：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>select object_type,object_schema,object_name,lock_type,lock_duration from
performance_schema.metadata_locks ;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_9-3-3-意向锁"><a href="#_9-3-3-意向锁" class="header-anchor">#</a> 9.3.3 意向锁</h3> <p>为了避免DML在执行时，加的<strong>行锁与表锁</strong>的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p> <ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li> <li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul> <p><strong>分类:</strong></p> <ul><li><p>意向共享锁(IS): 由语句select ... lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</p></li> <li><p>意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</p></li></ul> <p>普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p> <p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>//先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;

//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p></blockquote> <p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>演示:</strong></p> <p>意向共享锁与表读锁是兼容的</p> <p><img src="http://img.aismy.top/img/image-20220421152324657.png" alt="image-20220421152324657"></p> <p>意向排他锁与表读锁、写锁都是互斥的</p> <p><img src="http://img.aismy.top/img/image-20220421152729191.png" alt="image-20220421152729191"></p> <p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables ... read*）和独占表锁（*lock tables ... write*）发生冲突。</strong></p> <blockquote><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p> <p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p> <p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p></blockquote> <h2 id="_9-4-行级锁"><a href="#_9-4-行级锁" class="header-anchor">#</a> 9.4 行级锁</h2> <p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。
InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的
锁。对于行级锁，主要分为以下三类：</p> <ul><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在
RC、RR隔离级别下都支持。</li></ul> <p><img src="http://img.aismy.top/img/image-20220421153119819.png" alt="image-20220421153119819"></p> <ul><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事
务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li></ul> <p><img src="http://img.aismy.top/img/image-20220421153125604.png" alt="image-20220421153125604"></p> <ul><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。
在RR隔离级别下支持。</li></ul> <p><img src="http://img.aismy.top/img/image-20220421153130647.png" alt="image-20220421153130647"></p> <h3 id="_9-4-1-记录锁"><a href="#_9-4-1-记录锁" class="header-anchor">#</a> 9.4.1 记录锁</h3> <p>InnoDB实现了以下两种类型的行锁：</p> <ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li> <li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他
锁。</li></ul> <p>两种行锁的兼容情况如下:</p> <p><img src="http://img.aismy.top/img/image-20220421153322203.png" alt="image-20220421153322203"></p> <p>常见的SQL语句，在执行时，所加的行锁如下：</p> <img src="http://img.aismy.top/img/image-20220421153343658.png" alt="image-20220421153343658" style="zoom:50%;"> <p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜
索和索引扫描，以防止幻读。</p> <ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li> <li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记
录加锁，此时 就会升级为表锁。</li></ul> <p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from
performance_schema.data_locks;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>A.普通的select语句，执行时，不会加锁。</p> <p><img src="http://img.aismy.top/img/image-20220421154631966.png" alt="image-20220421154631966"></p> <p>B. select...lock in share mode，加共享锁，共享锁与共享锁之间兼容。</p> <p><img src="http://img.aismy.top/img/image-20220421154532742.png" alt="image-20220421154532742"></p> <p>共享锁与排他锁之间互斥。</p> <p><img src="http://img.aismy.top/img/image-20220421154740206.png" alt="image-20220421154740206"></p> <p>客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行
数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，以为共享锁与排他锁之间互
斥。</p> <p>C. 排它锁与排他锁之间互斥</p> <p><img src="http://img.aismy.top/img/image-20220421154812728.png" alt="image-20220421154812728"></p> <p>当客户端一，执行update语句，会为id为1的记录加排他锁； 客户端二，如果也执行update语句更
新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互
斥的。 直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞</p> <p>D. 无索引行锁升级为表锁</p> <p><img src="http://img.aismy.top/img/image-20220421155901982.png" alt="image-20220421155901982"></p> <p>我们在两个客户端中执行如下操作:</p> <p><img src="upload%5Cimage-20220421155921359.png" alt="image-20220421155921359"></p> <p>在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。
然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态，为什么呢？
原因就是因为此时，客户端一，根据name字段进行更新时，name字段是没有索引的，如果没有索引，
此时行锁会升级为表锁(因为行锁是对索引项加的锁，而name没有索引)。</p> <p><strong>上述结论存在问题:</strong></p> <blockquote><p>重新分析:</p> <p>InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。</p> <p>当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。</p> <p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。</p> <p>在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。</p> <p><strong>在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了</strong>。</p> <p>参考博客:https://xiaolincoding.com/mysql/lock/update_index.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E8%BF%99%E7%A7%8D%E7%9A%84%E4%BA%8B%E6%95%85</p></blockquote> <p>如何避免上述问题:</p> <blockquote><p>将 MySQL 里的 <code>sql_safe_updates</code> 参数设置为 1，开启安全更新模式。</p> <p>当 sql_safe_updates 设置为 1 时。</p> <p>update 语句必须满足如下条件之一才能执行成功：</p> <ul><li>使用 where，并且 where 条件中必须有索引列；</li> <li>使用 limit；</li> <li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul> <p>delete 语句必须满足以下条件能执行成功：</p> <ul><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul> <p>如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</p></blockquote> <h3 id="_9-4-2间隙锁-临键锁"><a href="#_9-4-2间隙锁-临键锁" class="header-anchor">#</a> 9.4.2间隙锁&amp;临键锁</h3> <p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。对记录加锁时，<strong>加锁的基本单位是 next-key lock</strong>，但是，next-key lock 在一些场景下会退化成记录锁或间隙锁:</p> <ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li> <li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</li> <li>索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。</li></ul> <blockquote><p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会
阻止另一个事务在同一间隙上采用间隙锁。</p></blockquote> <p><strong>演示:</strong></p> <p>A. 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</p> <p><img src="http://img.aismy.top/img/image-20220421160421352.png" alt="image-20220421160421352"></p> <blockquote><p>所以,在一个线程等值查询一个不存在值时,会将其间隙锁定,以此防止其他线程在该间隙插入,防止幻读;</p></blockquote> <p>B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key
lock 退化为间隙锁。</p> <p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值
为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个
结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也
就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p> <p><img src="http://img.aismy.top/img/image-20220421161051342.png" alt="image-20220421161051342"></p> <p><img src="http://img.aismy.top/img/image-20220421161059346.png" alt="image-20220421161059346"></p> <p>C. 索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。</p> <p><img src="http://img.aismy.top/img/image-20220421162306426.png" alt="image-20220421162306426"></p> <p>查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部
分：</p> <p>[19]
(19,25]
(25,+∞]
所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临
键锁(正无穷及之前的间隙)。</p> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结:</h3> <p>因为行级锁加锁规则比较复杂，不同的场景，加锁的形式还不同.</p> <p>对记录加锁时，<strong>加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。</p> <p>但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。</p> <h4 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="header-anchor">#</a> 唯一索引等值查询</h4> <p>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p> <ul><li><strong>当查询的记录是存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「记录锁」</strong>。</li> <li><strong>当查询的记录是不存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「间隙锁」</strong>。</li></ul> <h4 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="header-anchor">#</a> 唯一索引范围查询</h4> <p>范围查询和等值查询的加锁规则是不同的。</p> <p>查询的条件为id&gt;=19， 此时我们可以根据数据库表中现有的数据，将数据分为三个部
分：</p> <p>[19]
(19,25]
(25,+∞]
所以数据库数据在加锁是，就是将19加了记录锁锁，25的临键锁（包含25及25之前的间隙），正无穷的临
键锁(正无穷及之前的间隙)。</p> <h4 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="header-anchor">#</a> 非唯一索引等值查询</h4> <p>当我们用非唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p> <ul><li><strong>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁</strong>。</li></ul> <p>该间隙锁的规则是向下遍历到第一个不符合条件的值才能停止,即相当于锁定记录本身,以及两侧间隙</p> <ul><li><strong>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。</strong></li></ul> <h4 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="header-anchor">#</a> 非唯一索引范围查询</h4> <p>非唯一索引和主键索引的范围查询的加锁也有所不同</p> <ul><li>唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。</li> <li>非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。</li></ul> <h1 id="十、-innodb引擎"><a href="#十、-innodb引擎" class="header-anchor">#</a> 十、 InnoDB引擎</h1> <h2 id="_10-1-逻辑存储结构"><a href="#_10-1-逻辑存储结构" class="header-anchor">#</a> 10.1 逻辑存储结构</h2> <p>InnoDB的逻辑存储结构如下图所示:</p> <p><img src="http://img.aismy.top/img/image-20220421170619345.png" alt="image-20220421170619345"></p> <p>(1)表空间</p> <p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在
8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空
间，用于存储记录、索引等数据。</p> <p>(2)段</p> <p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段
（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的
非叶子节点。段用来管理多个Extent（区）。</p> <p>(3)区
区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一
个区中一共有64个连续的页。</p> <p>(4)页
页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，
InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p> <p>(5)行
行，InnoDB 存储引擎数据是按行进行存放的。
在行中，默认有两个隐藏字段：
Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。
Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个
隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p> <h2 id="_10-2-innodb-是如何存储数据的"><a href="#_10-2-innodb-是如何存储数据的" class="header-anchor">#</a> 10.2 InnoDB 是如何存储数据的？</h2> <p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。</p> <p>因此，<strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p> <p>数据库的 I/O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p> <p>数据页包括七个部分，结构如下图：</p> <img src="http://img.aismy.top/img/243b1466779a9e107ae3ef0155604a17.png" alt="图片" style="zoom:50%;"> <p>这 7 个部分的作用如下图：</p> <img src="http://img.aismy.top/img/fabd6dadd61a0aa342d7107213955a72.png" alt="图片" style="zoom:50%;"> <p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：</p> <img src="http://img.aismy.top/img/557d17e05ce90f18591c2305871af665.png" alt="图片" style="zoom:50%;"> <p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p> <p>数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。</p> <p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p> <p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p> <p>那 InnoDB 是如何给记录创建页目录的呢？页目录与记录的关系如下图：</p> <img src="http://img.aismy.top/img/261011d237bec993821aa198b97ae8ce.png" alt="图片" style="zoom:67%;"> <p>页目录创建的过程如下：</p> <ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li> <li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li> <li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol> <p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p> <p>以上面那张图举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：</p> <ul><li>先二分得出槽中间位是 (0+4)/2=2 ，2号槽里最大的记录为 8。因为 11 &gt; 8，所以需要从 2 号槽后继续搜索记录；</li> <li>再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)/2= 3，3 号槽里最大的记录为 12。因为 11 &lt; 12，所以主键为 11 的记录在 3 号槽里；</li> <li>这里有个问题，<strong>「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」</strong>？比如槽 3 对应最大主键是 12 的记录，那如何找到最小记录 9。解决办法是：通过槽 3 找到 槽 2 对应的记录，也就是主键为 8 的记录。主键为 8 的记录的下一条记录就是槽 3 当中主键最小的 9 记录，然后开始向下搜索 2 次，定位到主键为 11 的记录，取出该条记录的信息即为我们想要查找的内容。</li></ul> <p>看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p> <p>这点不用担心，InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p> <ul><li>第一个分组中的记录只能有 1 条记录；</li> <li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li> <li>剩下的分组中记录条数范围只能在 4-8 条之间。</li></ul> <blockquote><p>来源:https://xiaolincoding.com/mysql/index/page.html#b-%E6%A0%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84</p></blockquote> <h2 id="_10-3-架构"><a href="#_10-3-架构" class="header-anchor">#</a> 10.3 架构</h2> <p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发
中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p> <p><img src="http://img.aismy.top/img/image-20220421172440109.png" alt="image-20220421172440109"></p> <h3 id="_10-3-1-内存结构"><a href="#_10-3-1-内存结构" class="header-anchor">#</a> 10.3.1 内存结构</h3> <p><img src="http://img.aismy.top/img/image-20220421172706409.png" alt="image-20220421172706409"></p> <p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、AdaptiveHash Index、Log Buffer。 接下来介绍一下这四个部分。</p> <h4 id="_10-3-3-1-buffer-pool"><a href="#_10-3-3-1-buffer-pool" class="header-anchor">#</a> 10.3.3.1 Buffer Pool</h4> <p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能
弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁
盘I/O。
在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及
InnoDB的锁信息等等。</p> <p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增
删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频
率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p> <p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p> <ul><li>free page：空闲page，未被使用。</li> <li>clean page：被使用page，数据没有被修改过。</li> <li>dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。</li></ul> <p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置：<code>show variables like 'innodb_buffer_pool_size'</code>;</p> <h4 id="_10-3-3-2-change-buffer"><a href="#_10-3-3-2-change-buffer" class="header-anchor">#</a> 10.3.3.2 Change Buffer</h4> <p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page
没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer
中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。
Change Buffer的意义是什么呢?
先来看一幅图，这个是二级索引的结构图：</p> <p><img src="http://img.aismy.top/img/image-20220421173352489.png" alt="image-20220421173352489"></p> <p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新
可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了
ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p> <h4 id="_10-3-3-3-adaptive-hash-index"><a href="#_10-3-3-3-adaptive-hash-index" class="header-anchor">#</a> 10.3.3.3 Adaptive Hash Index</h4> <p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持
hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在
进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需
要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。
InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，
则建立hash索引，称之为自适应hash索引。</p> <p>自适应哈希索引，无需人工干预，是系统根据情况自动完成。
参数： <code>adaptive_hash_index</code></p> <h4 id="_10-3-3-4-log-buffer"><a href="#_10-3-3-4-log-buffer" class="header-anchor">#</a> 10.3.3.4 Log Buffer</h4> <p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），
默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事
务，增加日志缓冲区的大小可以节省磁盘 I/O。</p> <p><strong>参数:</strong> <code>innodb_log_buffer_size</code>：缓冲区大小
<code>innodb_flush_log_at_trx_commit</code>：日志刷新到磁盘时机，取值主要包含以下三个：</p> <ul><li>1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</li> <li>0:每秒将日志写入并刷新到磁盘一次。</li> <li>2:日志在每次事务提交后写入，并每秒刷新到磁盘一次。</li></ul> <h3 id="_10-3-2-磁盘结构"><a href="#_10-3-2-磁盘结构" class="header-anchor">#</a> 10.3.2 磁盘结构</h3> <p>接下来，再来看看InnoDB体系结构的右边部分，也就是磁盘结构：</p> <p><img src="http://img.aismy.top/img/image-20220421174317748.png" alt="image-20220421174317748"></p> <h4 id="_10-3-2-1-system-tablespace"><a href="#_10-3-2-1-system-tablespace" class="header-anchor">#</a> 10.3.2.1 System Tablespace</h4> <p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建
的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p> <p>参数：<code>innodb_data_file_path</code></p> <p><img src="http://img.aismy.top/img/image-20220421174502265.png" alt="image-20220421174502265"></p> <p>系统表空间，默认的文件名叫 ibdata1</p> <h4 id="_10-3-2-2-file-per-table-tablespaces"><a href="#_10-3-2-2-file-per-table-tablespaces" class="header-anchor">#</a> 10.3.2.2 File-Per-Table Tablespaces</h4> <p>如果开启了<code>innodb_file_per_table</code>开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索
引 ，并存储在文件系统上的单个数据文件中。
开关参数：<code>innodb_file_per_table</code> ，该参数默认开启。</p> <p><img src="http://img.aismy.top/img/image-20220421174702241.png" alt="image-20220421174702241"></p> <p>那也就是说，我们每创建一个表，都会产生一个表空间文件，如图：</p> <p><img src="http://img.aismy.top/img/image-20220421175158293.png" alt="image-20220421175158293"></p> <h4 id="_10-3-2-3-general-tablespaces"><a href="#_10-3-2-3-general-tablespaces" class="header-anchor">#</a> 10.3.2.3 General Tablespaces</h4> <p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空
间。</p> <p>创建表空间</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>CREATE TABLESPACE ts_name ADD DATAFILE 'file_name' ENGINE = engine_name; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>创建表时指定表空间</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>CREATE TABLE xxx ... TABLESPACE ts_name; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_10-3-2-4-undo-tablespaces"><a href="#_10-3-2-4-undo-tablespaces" class="header-anchor">#</a> 10.3.2.4 Undo Tablespaces</h4> <p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储
undo log日志。</p> <h4 id="_10-3-2-5-temporary-tablespaces"><a href="#_10-3-2-5-temporary-tablespaces" class="header-anchor">#</a> 10.3.2.5 Temporary Tablespaces</h4> <p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p> <h4 id="_10-3-2-6-doublewrite-buffer-files"><a href="#_10-3-2-6-doublewrite-buffer-files" class="header-anchor">#</a> 10.3.2.6 Doublewrite Buffer Files</h4> <p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件
中，便于系统异常时恢复数据。</p> <p><img src="http://img.aismy.top/img/image-20220421175424023.png" alt="image-20220421175424023"></p> <h4 id="_10-3-2-7-redo-log"><a href="#_10-3-2-7-redo-log" class="header-anchor">#</a> 10.3.2.7 Redo Log</h4> <p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log
buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所
有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。
以循环方式写入重做日志文件，涉及两个文件：</p> <p><img src="http://img.aismy.top/img/image-20220421175506670.png" alt="image-20220421175506670"></p> <p>前面我们介绍了InnoDB的内存结构，以及磁盘结构，那么内存中我们所更新的数据，又是如何到磁盘
中的呢？ 此时，就涉及到一组后台线程，接下来，就来介绍一些InnoDB中涉及到的后台线程。</p> <p><img src="http://img.aismy.top/img/image-20220421175519410.png" alt="image-20220421175519410"></p> <h3 id="_10-3-3后台线程"><a href="#_10-3-3后台线程" class="header-anchor">#</a> 10.3.3后台线程</h3> <img src="http://img.aismy.top/img/image-20220421175630760.png" alt="image-20220421175630760" style="zoom:67%;"> <p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、
Page Cleaner Thread。</p> <h4 id="master-thread"><a href="#master-thread" class="header-anchor">#</a> Master Thread</h4> <p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，
还包括脏页的刷新、合并插入缓存、undo页的回收 。</p> <h4 id="io-thread"><a href="#io-thread" class="header-anchor">#</a> IO Thread</h4> <p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO
Thread主要负责这些IO请求的回调。</p> <p><img src="http://img.aismy.top/img/image-20220421175724325.png" alt="image-20220421175724325"></p> <p>我们可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息。</p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>show engine innodb status \G; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><img src="http://img.aismy.top/img/image-20220421175935401.png" alt="image-20220421175935401" style="zoom:50%;"> <h4 id="purge-thread"><a href="#purge-thread" class="header-anchor">#</a> Purge Thread</h4> <p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回
收。</p> <h4 id="page-cleaner-thread"><a href="#page-cleaner-thread" class="header-anchor">#</a> Page Cleaner Thread</h4> <p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻
塞。</p> <h2 id="_10-4-事务原理"><a href="#_10-4-事务原理" class="header-anchor">#</a> 10.4 事务原理</h2> <h3 id="_10-4-1-事务基础"><a href="#_10-4-1-事务基础" class="header-anchor">#</a> 10.4.1 事务基础</h3> <h4 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h4> <p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系
统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p> <h4 id="特性"><a href="#特性" class="header-anchor">#</a> 特性</h4> <ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li> <li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li> <li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li> <li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul> <p>那实际上，我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p> <p><img src="http://img.aismy.top/img/image-20220421180303363.png" alt="image-20220421180303363"></p> <p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的
两份日志来保证的，一份是redo log日志，一份是undo log日志。 而隔离性是通过数据库的锁，
加上MVCC来保证的。</p> <p><img src="http://img.aismy.top/img/image-20220421180339878.png" alt="image-20220421180339878"></p> <h3 id="_10-4-2-redo-log"><a href="#_10-4-2-redo-log" class="header-anchor">#</a> 10.4.2 redo log</h3> <p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p> <p>该日志文件由两部分组成：</p> <ul><li>重做日志缓冲（redo log buffer）</li> <li>重做日志文件（redo logfile）</li></ul> <p>前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用
于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p> <blockquote><p>如果没有redolog，可能会存在什么问题的？ 我们一起来分析一下。</p></blockquote> <p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数
据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果
缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中
的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘
中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后
将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却
没有持久化下来，这就出现问题了，没有保证事务的持久性。</p> <p><img src="http://img.aismy.top/img/image-20220421180603940.png" alt="image-20220421180603940"></p> <p>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一
下，通过redolog如何解决这个问题。</p> <p><img src="http://img.aismy.top/img/image-20220421180612894.png" alt="image-20220421180612894"></p> <p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p> <h3 id="_10-4-3-undo-log"><a href="#_10-4-3-undo-log" class="header-anchor">#</a> 10.4.3 undo log</h3> <p>回滚日志，<strong>用于记录数据被修改前的信息</strong> , 作用包含两个 : 提供回滚(保证事务的原子性) 和
MVCC(多版本并发控制) 。</p> <p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo
log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的
update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。
Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些
日志可能还用于MVCC。</p> <p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment
回滚段中，内部包含1024个undo log segment。</p> <h2 id="_10-5-mvcc"><a href="#_10-5-mvcc" class="header-anchor">#</a> 10.5 MVCC</h2> <h3 id="_10-5-1-基本概念"><a href="#_10-5-1-基本概念" class="header-anchor">#</a> 10.5.1 基本概念</h3> <h4 id="_1-当前读"><a href="#_1-当前读" class="header-anchor">#</a> (1)当前读</h4> <p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加
锁。对于我们日常的操作，如：select ... lock in share mode(共享锁)，select ...for update、update、insert、delete(排他锁)都是一种当前读。</p> <p><img src="http://img.aismy.top/img/image-20220422101425042.png" alt="image-20220422101425042"></p> <p>在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内
容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们
加排他锁的时候，也是当前读操作。</p> <blockquote><p>因为要给记录加锁，因此需要读到最新记录，然后为其加锁</p></blockquote> <h4 id="_2-快照读"><a href="#_2-快照读" class="header-anchor">#</a> (2)快照读</h4> <p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，
不加锁，是非阻塞读。</p> <ul><li>Read Committed：每次select，都生成一个快照读。</li> <li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li> <li>Serializable：快照读会退化为当前读。</li></ul> <p>注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p> <ul><li>第一种：begin/start transaction 命令；</li> <li>第二种：start transaction with consistent snapshot 命令；</li></ul> <p>这两种开启事务的命令，事务的启动时机是不同的：</p> <ul><li>执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；</li> <li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li></ul> <p><img src="http://img.aismy.top/img/image-20220422101846488.png" alt="image-20220422101846488"></p> <p>右边更新事务提交后，然后左边执行快照读操作，可见是可以读到被修改的数据的，验证了开启事务后第一个select语句才是快照读的地方。</p> <p><img src="http://img.aismy.top/img/image-20220422102055399.png" alt="image-20220422102055399"></p> <p>右边客户端再次开启事务，执行更新操作后提交，但是左边读到的依然为第一次select生成的快照读。</p> <blockquote><p>普通的select是快照读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p></blockquote> <h4 id="_3-mvcc"><a href="#_3-mvcc" class="header-anchor">#</a> (3)MVCC</h4> <p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p> <h3 id="_10-5-2-隐藏字段"><a href="#_10-5-2-隐藏字段" class="header-anchor">#</a> 10.5.2 隐藏字段</h3> <p><img src="http://img.aismy.top/img/image-20220422102450540.png" alt="image-20220422102450540"></p> <p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了
这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p> <p><img src="http://img.aismy.top/img/image-20220422102522949.png" alt="image-20220422102522949"></p> <p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，
如果有主键，则不会添加该隐藏字段。</p> <h3 id="_10-5-3-记录版本链表"><a href="#_10-5-3-记录版本链表" class="header-anchor">#</a> 10.5.3 记录版本链表</h3> <h4 id="undo-log"><a href="#undo-log" class="header-anchor">#</a> undo log</h4> <p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p> <h4 id="版本链"><a href="#版本链" class="header-anchor">#</a> 版本链</h4> <p>有一张表原始数据为：</p> <p><img src="http://img.aismy.top/img/image-20220422103631089.png" alt="image-20220422103631089"></p> <blockquote><p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是
自增的。
DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p></blockquote> <p>然后，有四个并发事务同时在访问这张表。</p> <p>A. 第一步</p> <p><img src="http://img.aismy.top/img/image-20220422103731316.png" alt="image-20220422103731316"></p> <p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，
并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p> <p><img src="http://img.aismy.top/img/image-20220422103741684.png" alt="image-20220422103741684"></p> <p>B.第二步</p> <p><img src="http://img.aismy.top/img/image-20220422103753105.png" alt="image-20220422103753105"></p> <p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记
录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p> <p><img src="http://img.aismy.top/img/image-20220422103909459.png" alt="image-20220422103909459"></p> <p>C. 第三步</p> <p><img src="http://img.aismy.top/img/image-20220422103920091.png" alt="image-20220422103920091"></p> <p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记
录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p> <p><img src="http://img.aismy.top/img/image-20220422103930681.png" alt="image-20220422103930681"></p> <blockquote><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条
记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p></blockquote> <h3 id="_10-5-4-readview"><a href="#_10-5-4-readview" class="header-anchor">#</a> 10.5.4 readview</h3> <blockquote><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p></blockquote> <p>ReadView中包含了四个核心字段：</p> <p><img src="https://img-blog.csdnimg.cn/img_convert/11a65cbc2e97f6855d7692a265dc2651.png" alt="图片"></p> <p>Read View 有四个重要的字段：</p> <ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中**「活跃事务」的事务 id 列表**，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li> <li>min_trx_id ：指的是在创建 Read View 时，当前数据库中**「活跃事务」中事务 id 最小的事务**，也就是 m_ids 的最小值。</li> <li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li> <li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul> <p>而在readview中就规定了版本链数据的访问规则：trx_id 代表当前undolog版本链对应事务ID。</p> <p><img src="http://img.aismy.top/img/image-20220422104306577.png" alt="image-20220422104306577"></p> <p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p> <p><img src="http://img.aismy.top/img/ReadView.drawio.png" alt="img"></p> <p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p> <p>不同的隔离级别，生成ReadView的时机不同：</p> <ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li> <li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul> <h3 id="_10-5-5-原理分析"><a href="#_10-5-5-原理分析" class="header-anchor">#</a> 10.5.5 原理分析</h3> <ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li> <li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li> <li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View *<em>来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。*</em>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</li></ul> <h4 id="_10-5-5-1-rc隔离级别"><a href="#_10-5-5-1-rc隔离级别" class="header-anchor">#</a> 10.5.5.1 RC隔离级别</h4> <p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?</p> <p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下。</p> <p><img src="http://img.aismy.top/img/image-20220422104713975.png" alt="image-20220422104713975"></p> <p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，
到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p> <p>A. 先来看第一次快照读具体的读取过程：</p> <p><img src="http://img.aismy.top/img/image-20220422110651754.png" alt="image-20220422110651754"></p> <p><img src="http://img.aismy.top/img/image-20220422110657118.png" alt="image-20220422110657118"></p> <p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p> <ul><li>先匹配<img src="http://img.aismy.top/img/image-20220422110712776.png" alt="image-20220422110712776"> 这条记录，这条记录对应的
trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，
都不满足，则继续匹配undo log版本链的下一条。</li> <li>再匹配第二条<img src="http://img.aismy.top/img/image-20220422110811544.png" alt="image-20220422110811544">，这条
记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也
不满足 ，都不满足，则继续匹配undo log版本链的下一条。</li> <li>再匹配第三条<img src="http://img.aismy.top/img/image-20220422110831555.png" alt="image-20220422110831555">，这条记
录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照
读，返回的数据就是版本链中记录的这条数据。</li></ul> <p>B. 再来看第二次快照读具体的读取过程:</p> <p><img src="http://img.aismy.top/img/image-20220422111008802.png" alt="image-20220422111008802"><img src="upload%5Cimage-20220422111013833.png" alt="image-20220422111013833"></p> <p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p> <ul><li>先匹配<img src="http://img.aismy.top/img/image-20220422111138742.png" alt="image-20220422111138742">这条记录，这条记录对应的
trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，
都不满足，则继续匹配undo log版本链的下一条。</li> <li>再匹配第二条 <img src="http://img.aismy.top/img/image-20220422111153117.png" alt="image-20220422111153117">，这条
记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次
快照读，返回的数据就是版本链中记录的这条数据。</li></ul> <h4 id="_10-5-5-2-rr隔离级别"><a href="#_10-5-5-2-rr隔离级别" class="header-anchor">#</a> 10.5.5.2 RR隔离级别</h4> <p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。
那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p> <p><img src="http://img.aismy.top/img/image-20220422111334685.png" alt="image-20220422111334685"></p> <p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该
ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返
回的结果也是一样的。</p> <p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。
而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p> <p><img src="http://img.aismy.top/img/image-20220422111411111.png" alt="image-20220422111411111"></p> <h2 id="小结-2"><a href="#小结-2" class="header-anchor">#</a> 小结</h2> <p>事务是在 MySQL 引擎层实现的，我们常见的 InnoDB 引擎是支持事务的，事务的四大特性是原子性、一致性、隔离性、持久性，我们这次主要讲的是隔离性。</p> <p>当多个事务并发执行的时候，会引发脏读、不可重复读、幻读这些问题，那为了避免这些问题，SQL 提出了四种隔离级别，分别是读未提交、读已提交、可重复读、串行化，从左往右隔离级别顺序递增，隔离级别越高，意味着性能越差，InnoDB 引擎的默认隔离级别是可重复读。</p> <p>要解决脏读现象，就要将隔离级别升级到读已提交以上的隔离级别，要解决不可重复读现象，就要将隔离级别升级到可重复读以上的隔离级别。</p> <p>而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它通过 next-key lock 锁（行锁+间隙锁的组合）来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。</p> <p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View **来实现的，它们的区别在于创建 Read View 的时机不同：</p> <ul><li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li> <li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul> <p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p> <p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p> <h2 id="详解buffer-pool"><a href="#详解buffer-pool" class="header-anchor">#</a> 详解Buffer Pool</h2> <img src="http://img.aismy.top/img/e5a23e5c53ef471b947b5007866229fe.png" alt="img" style="zoom:33%;"> <h3 id="为什么要有-buffer-pool"><a href="#为什么要有-buffer-pool" class="header-anchor">#</a> 为什么要有 Buffer Pool？</h3> <p>虽然说 MySQL 的数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。</p> <p>要想提升查询性能，加个缓存就行了嘛。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p> <p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（*Buffer Pool*）</strong>，来提高数据库的读写性能。</p> <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/mysql/innodb/缓冲池.drawio.png" alt="img" style="zoom:50%;"> <p>有了缓冲池后：</p> <ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li> <li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</li></ul> <h5 id="buffer-pool-有多大"><a href="#buffer-pool-有多大" class="header-anchor">#</a> Buffer Pool 有多大？</h5> <p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code> 。</p> <p>可以通过调整 <code>innodb_buffer_pool_size</code> 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。</p> <h5 id="buffer-pool-缓存什么"><a href="#buffer-pool-缓存什么" class="header-anchor">#</a> Buffer Pool 缓存什么？</h5> <p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p> <p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p> <p>所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系。</p> <p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</p> <p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpool%E5%86%85%E5%AE%B9.drawio.png" alt="img"></p> <p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。</p> <p>控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页，如下图：</p> <p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png" alt="img"></p> <p>上图中控制块和缓存页之间灰色部分称为碎片空间。</p> <blockquote><p>为什么会有碎片空间呢？</p></blockquote> <p>你想想啊，每一个控制块都对应一个缓存页，那在分配足够多的控制块和缓存页后，可能剩余的那点儿空间不够一对控制块和缓存页的大小，自然就用不到喽，这个用不到的那点儿内存空间就被称为碎片了。</p> <p>当然，如果你把 Buffer Pool 的大小设置的刚刚好的话，也可能不会产生碎片。</p> <blockquote><p>查询一条记录，就只需要缓冲一条记录吗？</p></blockquote> <p>不是的。</p> <p>当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，因为，通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。</p> <h3 id="如何管理-buffer-pool"><a href="#如何管理-buffer-pool" class="header-anchor">#</a> 如何管理 Buffer Pool？</h3> <h4 id="如何管理空闲页"><a href="#如何管理空闲页" class="header-anchor">#</a> 如何管理空闲页？</h4> <p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。</p> <p>那当我们从磁盘读取数据的时候，总不能通过遍历这一片连续的内存空间来找到空闲的缓存页吧，这样效率太低了。</p> <p>所以，为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）。</p> <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/mysql/innodb/freelist.drawio.png" alt="img" style="zoom:67%;"> <p>Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。</p> <p>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。</p> <p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</p> <h4 id="如何管理脏页"><a href="#如何管理脏页" class="header-anchor">#</a> 如何管理脏页？</h4> <p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</p> <p>那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p> <p><img src="http://img.aismy.top/%E5%9B%BE%E5%83%8F1/Flush.drawio.png" alt="img"></p> <p>有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。</p> <h4 id="如何提高缓存命中率"><a href="#如何提高缓存命中率" class="header-anchor">#</a> 如何提高缓存命中率？</h4> <p>Buffer Pool 的大小是有限的，对于一些频繁访问的数据我们希望可以一直留在 Buffer Pool 中，而一些很少访问的数据希望可以在某些时机可以淘汰掉，从而保证 Buffer Pool 不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在 Buffer Pool 中。</p> <p>要实现这个，最容易想到的就是 LRU（Least recently used）算法。</p> <p>该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，从而腾出空间。</p> <p>简单的 LRU 算法的实现思路是这样的：</p> <ul><li>当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</li> <li>当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。</li></ul> <p>比如下图，假设 LRU 链表长度为 5，LRU 链表从左到右有 1，2，3，4，5 的页。</p> <p><img src="http://img.aismy.top/%E5%9B%BE%E5%83%8F1/lru.png" alt="img"></p> <p>如果访问了 3 号的页，因为 3 号页在 Buffer Pool 里，所以把 3 号页移动到头部即可。</p> <p><img src="http://img.aismy.top/%E5%9B%BE%E5%83%8F1/lru2.png" alt="img"></p> <p>而如果接下来，访问了 8 号页，因为 8 号页不在 Buffer Pool 里，所以需要先淘汰末尾的 5 号页，然后再将 8 号页加入到头部。</p> <p><img src="http://img.aismy.top/%E5%9B%BE%E5%83%8F1/lru3.png" alt="img"></p> <p>到这里我们可以知道，Buffer Pool 里有三种页和链表来管理数据。</p> <p>图中：</p> <ul><li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li> <li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li> <li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。</li></ul> <p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：</p> <ul><li>预读失效；</li> <li>Buffer Pool 污染；</li></ul> <blockquote><p>什么是预读失效？</p></blockquote> <p>先来说说 MySQL 的预读机制。程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。</p> <p>所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。</p> <p>但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。</p> <p>如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool空间不够的时候，还需要把末尾的页淘汰掉。</p> <p>如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。</p> <blockquote><p>怎么解决预读失效而导致缓存命中率降低的问题？</p></blockquote> <p>我们不能因为害怕预读失效，而将预读机制去掉，大部分情况下，局部性原理还是成立的。</p> <p>要避免预读失效带来影响，最好就是<strong>让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长</strong>。</p> <p>那到底怎么才能避免呢？</p> <p>MySQL 是这样做的，它改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。</p> <p>young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：</p> <p><img src="http://img.aismy.top/%E5%9B%BE%E5%83%8F1/young+old.png" alt="img"></p> <p>old 区域占整个 LRU 链表长度的比例可以通过 <code>innodb_old_blocks_pc</code> 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。</p> <p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p> <p>接下来，给大家举个例子。</p> <p>假设有一个长度为 10 的 LRU 链表，其中 young 区域占比 70 %，old 区域占比 20 %。</p> <p><img src="http://img.aismy.top/%E5%9B%BE%E5%83%8F1/lrutwo.drawio.png" alt="img"></p> <p>现在有个编号为 20 的页被预读了，这个页只会被插入到 old 区域头部，而 old 区域末尾的页（10号）会被淘汰掉。</p> <p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/mysql/innodb/lrutwo2.png" alt="img"></p> <p>如果 20 号页一直不会被访问，它也没有占用到 young 区域的位置，而且还会比 young 区域的数据更早被淘汰出去。</p> <p>如果 20 号页被预读后，立刻被访问了，那么就会将它插入到 young 区域的头部，young 区域末尾的页（7号），会被挤到 old 区域，作为 old 区域的头部，这个过程并不会有页被淘汰。</p> <p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/mysql/innodb/lrutwo3.png" alt="img"></p> <p>虽然通过划分 old 区域 和 young 区域避免了预读失效带来的影响，但是还有个问题无法解决，那就是 Buffer Pool 污染的问题。</p> <blockquote><p>什么是 Buffer Pool 污染？</p></blockquote> <p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p> <p>注意， Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。</p> <p>比如，在一个数据量非常大的表，执行了这条语句：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">&quot;%xiaolin%&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：</p> <ul><li>从磁盘读到的页加入到 LRU 链表的 old 区域头部；</li> <li>当从页里读取行记录时，也就是页被访问的时候，就要将该页放到 young 区域头部；</li> <li>接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；</li> <li>如此往复，直到扫描完表中的所有记录。</li></ul> <p>经过这一番折腾，原本 young 区域的热点数据都会被替换掉。</p> <p>举个例子，假设需要批量扫描：21，22，23，24，25 这五个页，这些页都会被逐一访问（读取页里的记录）。</p> <p><img src="http://img.aismy.top/%E5%9B%BE%E5%83%8F1/lruthree.drawio.png" alt="img"></p> <p>在批量访问这些数据的时候，会被逐一插入到 young 区域头部。</p> <p><img src="http://img.aismy.top/%E5%9B%BE%E5%83%8F1/lruthree1.png" alt="img"></p> <p>可以看到，原本在 young 区域的热点数据 6 和 7 号页都被淘汰了，这就是 Buffer Pool 污染的问题。</p> <blockquote><p>怎么解决出现 Buffer Pool 污染而导致缓存命中率下降的问题？</p></blockquote> <p>像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。</p> <p>LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。</p> <p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p> <p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p> <ul><li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li> <li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li></ul> <p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p> <p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。</p> <p>另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会。</p> <h4 id="脏页什么时候会被刷入磁盘"><a href="#脏页什么时候会被刷入磁盘" class="header-anchor">#</a> 脏页什么时候会被刷入磁盘？</h4> <p>引入了 Buffer Pool 后，当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，但是磁盘中还是原数据。</p> <p>因此，脏页需要被刷入磁盘，保证缓存和磁盘数据一致，但是若每次修改数据都刷入磁盘，则性能会很差，因此一般都会在一定时机进行批量刷盘。</p> <p>可能大家担心，如果在脏页还没有来得及刷入到磁盘时，MySQL 宕机了，不就丢失数据了吗？</p> <p>这个不用担心，InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p> <p>下面几种情况会触发脏页的刷新：</p> <ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li> <li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li> <li>MySQL 认为空闲时，后台线程回定期将适量的脏页刷入到磁盘；</li> <li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li></ul> <p>在我们开启了慢 SQL 监控后，如果你发现**「偶尔」会出现一些用时稍长的 SQL**，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。</p> <p>如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>Innodb 存储引擎设计了一个<strong>缓冲池（*Buffer Pool*）</strong>，来提高数据库的读写性能。</p> <p>Buffer Pool 以页为单位缓冲数据，可以通过 <code>innodb_buffer_pool_size</code> 参数调整缓冲池的大小，默认是 128 M。</p> <p>Innodb 通过三种链表来管理缓页：</p> <ul><li>Free List （空闲页链表），管理空闲页；</li> <li>Flush List （脏页链表），管理脏页；</li> <li>LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；</li></ul> <p>InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：</p> <ul><li>将 LRU 链表 分为<strong>young 和 old 两个区域</strong>，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。</li> <li>当**「页被访问」且「 old 区域停留时间超过 <code>innodb_old_blocks_time</code> 阈值（默认为1秒）」**时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。</li></ul> <p>可以通过调整 <code>innodb_old_blocks_pc</code> 参数，设置 young 区域和 old 区域比例。</p> <p>在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/Aismy/aismy.github.io/edit/master/docs/02.数据库/01.数据库/01.MySQL.md" target="_blank" rel="noopener noreferrer">在线编辑此文章</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/pages/1ce2e2/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Redis</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/1ce2e2/">Redis</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:752704491@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/Aismy" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2023
    <span>Aismy | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b738e2cf.js" defer></script><script src="/assets/js/2.ffb45a81.js" defer></script><script src="/assets/js/23.6a79feac.js" defer></script>
  </body>
</html>
